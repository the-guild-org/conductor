{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "title": "ConductorConfig",
  "description": "This section describes the top-level configuration object for Conductor gateway.\nConductor supports both YAML and JSON format for the configuration file.\n## Loading the config file\nThe configuration is loaded when server starts, based on the runtime environment you are using:\n### Binary\nIf you are running the Conductor binary directly, you can specify the configuration file path using the first argument:\n```sh\nconductor my-config-file.json\n```\n> By default, Conductor will look for a file named `config.json` in the current directory.\n### Docker\nIf you are using Docker environment, you can mount the configuration file into the container, and then point the Conductor binary to it:\n```sh\ndocker run -v my-config-file.json:/app/config.json the-guild-org/conductor-t2:latest /app/config.json\n```\n### CloudFlare Worker\nWASM runtime doesn't allow filesystem access, so you need to load the configuration file into an environment variable named `CONDUCTOR_CONFIG`.\n## Autocomplete/validation in VSCode\nFor JSON files, you can specify the `$schema` property to enable autocomplete and validation in VSCode:\n```json filename=\"config.json\"\n{ \"$schema\": \"https://raw.githubusercontent.com/the-guild-org/conductor-t2/master/libs/config/conductor.schema.json\" }\n```\nFor YAML auto-complete and validation, you can install the [YAML Language Support](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml) extension and enable it by adding the following to your YAML file:\n```yaml filename=\"config.yaml\"\n$schema: \"https://raw.githubusercontent.com/the-guild-org/conductor-t2/master/libs/config/conductor.schema.json\"\n```\n### JSONSchema\nAs part of the release flow of Conductor, we are publishing the configuration schema as a JSONSchema file.\nYou can find [here the latest version of the schema](https://github.com/the-guild-org/conductor-t2/releases).\n### Configuration Interpolation with Environment Variables\nThis feature allows the dynamic insertion of environment variables into the config file for Conductor. It enhances flexibility by adapting the configuration based on the runtime environment.\nSyntax for Environment Variable Interpolation: - Use `${VAR_NAME}` to insert the value of an environment variable. If `VAR_NAME` is not set, an error will pop up. - Specify a default value with `${VAR_NAME:default_value}` which is used when `VAR_NAME` is not set. - Escape a dollar sign by preceding it with a backslash (e.g., `\\$`) to use it as a literal character instead of triggering interpolation.\nExamples: - `endpoint: ${API_ENDPOINT:https://api.example.com/}` - Uses the `API_ENDPOINT` variable or defaults to the provided URL. - `name: \\$super` - Results in the literal string `name: \\$super` in the configuration.",
  "type": "object",
  "required": [
    "endpoints",
    "sources"
  ],
  "properties": {
    "server": {
      "description": "Configuration for the HTTP server.",
      "anyOf": [
        {
          "$ref": "#/definitions/ServerConfig"
        },
        {
          "type": "null"
        }
      ]
    },
    "logger": {
      "description": "Conductor logger configuration.",
      "anyOf": [
        {
          "$ref": "#/definitions/LoggerConfig"
        },
        {
          "type": "null"
        }
      ]
    },
    "sources": {
      "description": "List of sources to be used by the gateway. Each source is a GraphQL endpoint or multiple endpoints grouped using a federated implementation.\nFor additional information, please refer to the [Sources section](./sources/graphql).",
      "type": "array",
      "items": {
        "$ref": "#/definitions/SourceDefinition"
      }
    },
    "endpoints": {
      "description": "List of GraphQL endpoints to be exposed by the gateway. Each endpoint is a GraphQL schema that is backed by one or more sources and can have a unique set of plugins applied to.\nFor additional information, please refer to the [Endpoints section](./endpoints).",
      "type": "array",
      "items": {
        "$ref": "#/definitions/EndpointDefinition"
      }
    },
    "plugins": {
      "description": "List of global plugins to be applied to all endpoints. Global plugins are applied before endpoint-specific plugins.",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/definitions/PluginDefinition"
      }
    }
  },
  "definitions": {
    "ServerConfig": {
      "type": "object",
      "properties": {
        "port": {
          "description": "The port to listen on, default to 9000",
          "default": 9000,
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "host": {
          "description": "The host to listen on, default to 127.0.0.1",
          "default": "127.0.0.1",
          "type": "string"
        }
      }
    },
    "LoggerConfig": {
      "type": "object",
      "properties": {
        "level": {
          "description": "Log level",
          "default": "info",
          "$ref": "#/definitions/Level"
        }
      }
    },
    "Level": {
      "type": "string",
      "enum": [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ]
    },
    "SourceDefinition": {
      "description": "A source definition for a GraphQL endpoint or a federated GraphQL implementation.",
      "oneOf": [
        {
          "description": "A simple, single GraphQL endpoint",
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "graphql"
              ]
            },
            "id": {
              "description": "The identifier of the source. This is used to reference the source in the `from` field of an endpoint definition.",
              "type": "string"
            },
            "config": {
              "description": "The configuration for the GraphQL source.",
              "$ref": "#/definitions/GraphQLSourceConfig"
            }
          }
        }
      ]
    },
    "GraphQLSourceConfig": {
      "description": "An upstream based on a simple, single GraphQL endpoint.\nBy using this source, you can easily wrap an existing GraphQL upstream server, and enrich it with features and plugins.",
      "examples": [
        {
          "$metadata": {
            "title": "Simple",
            "description": null
          },
          "type": "graphql",
          "id": "my-source",
          "config": {
            "endpoint": "https://my-source.com/graphql"
          }
        }
      ],
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "endpoint": {
          "description": "The HTTP(S) endpoint URL for the GraphQL source.",
          "type": "string"
        }
      }
    },
    "EndpointDefinition": {
      "description": "The `Endpoint` object exposes a GraphQL source with set of plugins applied to it.\nEach Endpoint can have its own set of plugins, which are applied after the global plugins. Endpoints can expose the same source with different plugins applied to it, to create different sets of features for different clients or consumers.",
      "examples": [
        {
          "$metadata": {
            "title": "Basic Example",
            "description": "This example demonstrate how to declare a GraphQL source, and expose it as a GraphQL endpoint. The endpoint also exposes a GraphiQL interface."
          },
          "sources": [
            {
              "type": "graphql",
              "id": "my-source",
              "config": {
                "endpoint": "https://my-source.com/graphql"
              }
            }
          ],
          "endpoints": [
            {
              "path": "/graphql",
              "from": "my-source",
              "plugins": [
                {
                  "type": "graphiql"
                }
              ]
            }
          ]
        },
        {
          "$metadata": {
            "title": "Multiple Endpoints",
            "description": "This example shows how to expose a single GraphQL source with different plugins applied to it. In this example, we expose the same, one time with persised operations, and one time with HTTP GET for arbitrary queries."
          },
          "sources": [
            {
              "type": "graphql",
              "id": "my-source",
              "config": {
                "endpoint": "https://my-source.com/graphql"
              }
            }
          ],
          "endpoints": [
            {
              "path": "/persisted",
              "from": "my-source",
              "plugins": [
                {
                  "type": "persisted_operations",
                  "config": {
                    "store": {
                      "source": "file",
                      "path": "store.json",
                      "format": "json_key_value"
                    },
                    "protocols": [
                      {
                        "type": "document_id",
                        "field_name": ""
                      }
                    ],
                    "allow_non_persisted": false
                  }
                }
              ]
            },
            {
              "path": "/data",
              "from": "my-source",
              "plugins": [
                {
                  "type": "http_get",
                  "config": {
                    "mutations": false
                  }
                }
              ]
            }
          ]
        }
      ],
      "type": "object",
      "required": [
        "from",
        "path"
      ],
      "properties": {
        "path": {
          "description": "A valid HTTP path to listen on for this endpoint. This will be used for the main GraphQL endpoint as well as for the GraphiQL endpoint. In addition, plugins that extends the HTTP layer will use this path as a base path.",
          "type": "string"
        },
        "from": {
          "description": "The identifier of the `Source` to be used.\nThis must match the `id` field of a `Source` definition.",
          "type": "string"
        },
        "plugins": {
          "description": "A list of unique plugins to be applied to this endpoint. These plugins will be applied after the global plugins.\nOrder of plugins is important: plugins are applied in the order they are defined.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/PluginDefinition"
          }
        }
      }
    },
    "PluginDefinition": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "graphiql"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/GraphiQLPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "http_get"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/HttpGetPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "vrl"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "$ref": "#/definitions/VrlPluginConfig"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "persisted_operations"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "$ref": "#/definitions/PersistedOperationsPluginConfig"
            }
          }
        }
      ]
    },
    "GraphiQLPluginConfig": {
      "description": "This plugin adds a GraphiQL interface to your Endpoint.\nThis plugin is rendering the GraphiQL interface for HTTP `GET` requests, that are not intercepted by other plugins.",
      "examples": [
        {
          "$metadata": {
            "title": "Enable GraphiQL",
            "description": null
          },
          "type": "graphiql",
          "config": {}
        }
      ],
      "type": "object",
      "properties": {
        "headers_editor_enabled": {
          "description": "Enable/disable the HTTP headers editor in the GraphiQL interface.",
          "default": true,
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "HttpGetPluginConfig": {
      "description": "The `http_get` plugin allows you to expose your GraphQL API over HTTP `GET` requests. This feature is fully compliant with the [GraphQL over HTTP specification](https://graphql.github.io/graphql-over-http/).\nBy enabling this plugin, you can execute GraphQL queries and mutations over HTTP `GET` requests, using HTTP query parameters, for example:\n`GET /graphql?query=query%20%7B%20__typename%20%7D`\n### Query Parameters\nFor complete documentation of the supported query parameters, see the [GraphQL over HTTP specification](https://graphql.github.io/graphql-over-http/draft/#sec-GET).\n- `query`: The GraphQL query to execute\n- `variables` (optional): A JSON-encoded string containing the GraphQL variables\n- `operationName` (optional): The name of the GraphQL operation to execute\n### Headers\nTo execute GraphQL queries over HTTP `GET` requests, you must set the `Content-Type` header to `application/json`, **or** the `Accept` header to `application/x-www-form-urlencoded` / `application/graphql-response+json`.",
      "examples": [
        {
          "$metadata": {
            "title": "Simple",
            "description": null
          },
          "type": "http_get",
          "config": {}
        },
        {
          "$metadata": {
            "title": "Enable Mutations",
            "description": "This example enables mutations over HTTP GET requests."
          },
          "type": "http_get",
          "config": {
            "mutations": true
          }
        }
      ],
      "type": "object",
      "properties": {
        "mutations": {
          "description": "Allow mutations over GET requests.\n**The option is disabled by default:** this restriction is necessary to conform with the long-established semantics of safe methods within HTTP.",
          "default": false,
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "VrlPluginConfig": {
      "description": "To simplify the process of extending the functionality of the GraphQL Gateway, we adopted a Rust-based script language called [VRL](https://vector.dev/docs/reference/vrl/).\nVRL language is intended for writing simple scripts that can be executed in the context of the GraphQL Gateway. VRL is focused around safety and performance: the script is compiled into Rust code when the server starts, and executed as a native Rust code ([you can find a comparison between VRL and other scripting languages here](https://github.com/YassinEldeeb/rust-embedded-langs-vs-native-benchmark)).\n> VRL was initially created to allow users to extend [Vector](https://vector.dev/), a high-performance observability data router, and adopted for Conductor to allow developers to extend the functionality of the GraphQL Gateway easily.\n### Writing VRL\nVRL is an expression-oriented language. A VRL program consists entirely of expressions, with every expression returning a value. You can define variables, call functions, and use operators to manipulate values.\n#### Variables and Functions\nThe following program defines a variable `myVar` with the value `\"myValue\"` and prints it to the console:\n```vrl\nmyVar = \"my value\"\nlog(myVar, level:\"info\")\n```\n#### Assignment\nThe `.` is used to set output values. In this example, we are setting the `x-authorization` header of the upstream HTTP request to `my-value`.\nHere's an example for a VRL program that extends Conductor's behavior by adding a custom HTTP header to all upstream HTTP requests:\n```vrl\n.upstream_http_req.headers.\"x-authorization\" = \"my-value\"\n```\n#### Metadata\nThe `%` is used to access metadata values. Note that metadata values are read only.\nThe following program is printing a metadata value to the console:\n```vrl\nlog(%downstream_http_req.headers.authorization, level:\"info\")\n```\n#### Further Reading\n- [VRL Playground](https://playground.vrl.dev/)\n- [VRL concepts documentation](https://vector.dev/docs/reference/vrl/#concepts)\n- [VRL syntax documentation](https://vector.dev/docs/reference/vrl/expressions/)\n- [Compiler errors documentation](https://vector.dev/docs/reference/vrl/errors/)\n- [VRL program examples](https://vector.dev/docs/reference/vrl/examples/)\n### Runtime Failure Handling\nSome VRL functions are fallible, meaning that they can error. Any potential errors thrown by fallible functions must be handled, a requirement enforced at compile time.\n```vrl\n# This function is fallible, and can create errors, so it must be handled.\nparsed, err = parse_json(\"invalid json\")\n```\nVRL function calls can be marked as infallible by adding a `!` suffix to the function call: (note that this might lead to runtime errors)\n```vrl\nparsed = parse_json!(\"invalid json\")\n```\n> In case of a runtime error of a fallible function call, an error will be returned to the end-user, and the gateway will not continue with the execution.\n### Input/Output\n#### `on_downstream_http_request`\nThe `on_downstream_http_request` hook is executed when a downstream HTTP request is received to the gateway from the end-user.\nThe following metadata inputs are available to the hook:\n- `%downstream_http_req.body` (type: `string`): The body string of the incoming HTTP request.\n- `%downstream_http_req.uri` (type: `string`): The URI of the incoming HTTP request.\n- `%downstream_http_req.query_string` (type: `string`): The query string of the incoming HTTP request.\n- `%downstream_http_req.method` (type: `string`): The HTTP method of the incoming HTTP request.\n- `%downstream_http_req.headers` (type: `object`): The HTTP headers of the incoming HTTP request.\nThe following output values are available to the hook:\n- `.graphql.operation` (type: `string`): The GraphQL operation string to be executed. If this value is set, the gateway will skip the lookup phase, and will use this GraphQL operation instead.\n- `.graphql.operation_name` (type: `string`): If multiple GraphQL operations are set in `.graphql.operation`, you can specify the executable operation by setting this value.\n- `.graphql.variables` (type: `object`): The GraphQL variables to be used when executing the GraphQL operation.\n- `.graphql.extensions` (type: `object`): The GraphQL extensions to be used when executing the GraphQL operation.\n#### `on_downstream_graphql_request`\nThe `on_downstream_graphql_request` hook is executed when a GraphQL operation is extracted from a downstream HTTP request, and before the upstream GraphQL request is sent.\nThe following metadata inputs are available to the hook:\n- `%downstream_graphql_req.operation` (type: `string`): The GraphQL operation string, as extracted from the incoming HTTP request.\n- `%downstream_graphql_req.operation_name`(type: `string`) : If multiple GraphQL operations are set in `%downstream_graphql_req.operation`, you can specify the executable operation by setting this value.\n- `%downstream_graphql_req.variables` (type: `object`): The GraphQL variables, as extracted from the incoming HTTP request.\n- `%downstream_graphql_req.extensions` (type: `object`): The GraphQL extensions, as extracted from the incoming HTTP request.\nThe following output values are available to the hook:\n- `.graphql.operation` (type: `string`): The GraphQL operation string to be executed. If this value is set, it will override the existing operation.\n- `.graphql.operation_name` (type: `string`): If multiple GraphQL operations are set in `.graphql.operation`, you can override the extracted value by setting this field.\n- `%downstream_graphql_req.variables` (type: `object`): The GraphQL variables, as extracted from the incoming HTTP request. Setting this value will override the existing variables.\n- `%downstream_graphql_req.extensions` (type: `object`): The GraphQL extensions, as extracted from the incoming HTTP request. Setting this value will override the existing extensions.\n#### `on_upstream_http_request`\nThe `on_upstream_http_request` hook is executed when an HTTP request is about to be sent to the upstream GraphQL server.\nThe following metadata inputs are available to the hook:\n- `%upstream_http_req.body` (type: `string`): The body string of the planned HTTP request.\n- `%upstream_http_req.uri` (type: `string`): The URI of the planned HTTP request.\n- `%upstream_http_req.query_string` (type: `string`): The query string of the planned HTTP request.\n- `%upstream_http_req.method` (type: `string`): The HTTP method of the planned HTTP request.\n- `%upstream_http_req.headers` (type: `object`): The HTTP headers of the planned HTTP request.\nThe following output values are available to the hook:\n- `.upstream_http_req.body` (type: `string`): The body string of the planned HTTP request. Setting this value will override the existing body.\n- `.upstream_http_req.uri` (type: `string`): The URI of the planned HTTP request. Setting this value will override the existing URI.\n- `.upstream_http_req.query_string` (type: `string`): The query string of the planned HTTP request. Setting this value will override the existing query string.\n- `.upstream_http_req.method` (type: `string`): The HTTP method of the planned HTTP request. Setting this value will override the existing HTTP method.\n- `.upstream_http_req.headers` (type: `object`): The HTTP headers of the planned HTTP request. Headers set here will only extend the existing headers. You can use `null` value if you wish to remove an existing header.\n#### `on_downstream_http_response`\nThe `on_downstream_http_response` hook is executed when a GraphQL response is received from the upstream GraphQL server, and before the response is sent to the end-user.\nThe following metadata inputs are available to the hook:\n- `%downstream_http_res.body` (type: `string`): The body string of the HTTP response.\n- `%downstream_http_res.status` (type: `number`): The status code of the HTTP response.\n- `%downstream_http_res.headers` (type: `object`): The HTTP headers of the HTTP response.\nThe following output values are available to the hook:\n- `.downstream_http_res.body` (type: `string`): The body string of the HTTP response. Setting this value will override the existing body.\n- `.downstream_http_res.status` (type: `number`): The status code of the HTTP response. Setting this value will override the existing status code.\n- `.downstream_http_res.headers` (type: `object`): The HTTP headers of the HTTP response. Headers set here will only extend the existing headers. You can use `null` value if you wish to remove an existing header.\n### Shared State\nDuring the execution of VRL programs, Conductor configures a shared state object for every incoming HTTP request.\nThis means that you can create type-safe shared state objects, and use them to share data between different VRL programs and hooks.\nYou can find an example for this in the **Examples** section below.\n### Available Functions",
      "examples": [
        {
          "$metadata": {
            "title": "Inline",
            "description": "Load and execute VRL plugins using inline configuration."
          },
          "type": "vrl",
          "config": {
            "on_upstream_http_request": {
              "from": "inline",
              "content": ".upstream_http_req.headers.\"x-authorization\" = \"some-value\"\n                    "
            }
          }
        },
        {
          "$metadata": {
            "title": "File",
            "description": "Load and execute VRL plugins using an external '.vrl' file."
          },
          "type": "vrl",
          "config": {
            "on_upstream_http_request": {
              "from": "file",
              "path": "my_plugin.vrl"
            }
          }
        },
        {
          "$metadata": {
            "title": "Headers Passthrough",
            "description": "This example is using the shared-state feature to store the headers from the incoming HTTP request, and it pass it through to upstream calls."
          },
          "type": "vrl",
          "config": {
            "on_downstream_http_request": {
              "from": "inline",
              "content": "incoming_headers = %downstream_http_req.headers\n                    "
            },
            "on_upstream_http_request": {
              "from": "inline",
              "content": ".upstream_http_req.headers = incoming_headers\n                    "
            }
          }
        },
        {
          "$metadata": {
            "title": "Shared State",
            "description": "The following example is configuring a variable, and use it later"
          },
          "type": "vrl",
          "config": {
            "on_downstream_http_request": {
              "from": "inline",
              "content": "authorization_header = %downstream_http_req.headers.authorization\n                    "
            },
            "on_upstream_http_request": {
              "from": "inline",
              "content": ".upstream_http_req.headers.\"x-auth\" = authorization_header\n                    "
            }
          }
        },
        {
          "$metadata": {
            "title": "Short Circuit",
            "description": "The following example rejects all incoming requests that doesn't have the \"authorization\" header set."
          },
          "type": "vrl",
          "config": {
            "on_downstream_http_request": {
              "from": "inline",
              "content": "if %downstream_http_req.headers.authorization == null {\n  short_circuit!(403, \"Missing authorization header\")\n}\n                    "
            }
          }
        },
        {
          "$metadata": {
            "title": "Custom GraphQL Extraction",
            "description": "The following example is using a custom GraphQL extraction, overriding the default gateway behavior. In this example, we parse the incoming body as JSON and use the parsed value to find the GraphQL operation. Assuming the body structure is: `{ \"runThisQuery\": \"query { __typename }\", \"variables\": {  }`."
          },
          "type": "vrl",
          "config": {
            "on_downstream_http_request": {
              "from": "inline",
              "content": "parsed_body = parse_json!(%downstream_http_req.body)\n.graphql.operation = parsed_body.runThisQuery\n.graphql.variables = parsed_body.variables\n                    "
            }
          }
        }
      ],
      "type": "object",
      "properties": {
        "on_downstream_http_request": {
          "description": "A hook executed when a downstream HTTP request is received to the gateway from the end-user. This hook allow you to extract information from the request, for later use, or to reject a request quickly.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_downstream_graphql_request": {
          "description": "A hook executed when a GraphQL query is extracted from a downstream HTTP request, and before the upstream GraphQL request is sent. This hooks allow you to easily manipulate the incoming GraphQL request.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_upstream_http_request": {
          "description": "A hook executed when an HTTP request is about to be sent to the upstream GraphQL server. This hook allow you to manipulate upstream HTTP calls easily.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_downstream_http_response": {
          "description": "A hook executed when a GraphQL response is received from the upstream GraphQL server, and before the response is sent to the end-user. This hook allow you to manipulate the end-user response easily.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "VrlConfigReference": {
      "oneOf": [
        {
          "title": "inline",
          "description": "Inline string for a VRL code snippet. The string is parsed and executed as a VRL plugin.",
          "type": "object",
          "required": [
            "content",
            "from"
          ],
          "properties": {
            "from": {
              "type": "string",
              "enum": [
                "inline"
              ]
            },
            "content": {
              "type": "string"
            }
          }
        },
        {
          "title": "file",
          "description": "File reference to a VRL file. The file is loaded and executed as a VRL plugin.",
          "type": "object",
          "required": [
            "from",
            "path"
          ],
          "properties": {
            "from": {
              "type": "string",
              "enum": [
                "file"
              ]
            },
            "path": {
              "$ref": "#/definitions/LocalFileReference"
            }
          }
        }
      ]
    },
    "LocalFileReference": {
      "type": "string",
      "format": "path"
    },
    "PersistedOperationsPluginConfig": {
      "examples": [
        {
          "$metadata": {
            "title": "Local File Store",
            "description": "This example is using a local file called `persisted_operations.json` as a store, using the Key->Value map format. The protocol exposed is based on HTTP `POST`, using the `documentId` parameter from the request body."
          },
          "type": "persisted_operations",
          "config": {
            "store": {
              "source": "file",
              "path": "persisted_operations.json",
              "format": "json_key_value"
            },
            "protocols": [
              {
                "type": "document_id",
                "field_name": "documentId"
              }
            ]
          }
        },
        {
          "$metadata": {
            "title": "HTTP GET",
            "description": "This example uses a local file store called `persisted_operations.json`, using the Key->Value map format. The protocol exposed is based on HTTP `GET`, and extracts all parameters from the query string."
          },
          "type": "persisted_operations",
          "config": {
            "store": {
              "source": "file",
              "path": "persisted_operations.json",
              "format": "json_key_value"
            },
            "protocols": [
              {
                "type": "http_get",
                "document_id_from": {
                  "source": "search_query",
                  "name": "documentId"
                },
                "variables_from": {
                  "source": "search_query",
                  "name": "variables"
                },
                "operation_name_from": {
                  "source": "search_query",
                  "name": "operationName"
                }
              }
            ]
          }
        }
      ],
      "type": "object",
      "required": [
        "protocols",
        "store"
      ],
      "properties": {
        "store": {
          "description": "The store defines the source of persisted documents. The store contents is a list of hashes and GraphQL documents that are allowed to be executed.",
          "$ref": "#/definitions/PersistedOperationsPluginStoreConfig"
        },
        "protocols": {
          "description": "A list of protocols to be exposed by this plugin. Each protocol defines how to obtain the document ID from the incoming request. You can specify multiple kinds of protocols, if needed.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/PersistedOperationsProtocolConfig"
          }
        },
        "allow_non_persisted": {
          "description": "By default, this plugin does not allow non-persisted operations to be executed. This is a security measure to prevent accidental exposure of operations that are not persisted.",
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "PersistedOperationsPluginStoreConfig": {
      "oneOf": [
        {
          "title": "file",
          "description": "File-based store configuration. The path specified is relative to the location of the root configuration file. The file contents are loaded into memory on startup. The file is not reloaded automatically. The file format is specified by the `format` field, based on the structure of your file.",
          "type": "object",
          "required": [
            "format",
            "path",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "file"
              ]
            },
            "path": {
              "description": "A path to a local file on the file-system. Relative to the location of the root configuration file.",
              "$ref": "#/definitions/LocalFileReference"
            },
            "format": {
              "description": "The format and the expected structure of the loaded store file.",
              "$ref": "#/definitions/PersistedDocumentsFileFormat"
            }
          }
        }
      ]
    },
    "PersistedDocumentsFileFormat": {
      "oneOf": [
        {
          "title": "apollo_persisted_query_manifest",
          "description": "JSON file formated based on [Apollo Persisted Query Manifest](https://www.apollographql.com/docs/kotlin/advanced/persisted-queries/#1-generate-operation-manifest).",
          "type": "string",
          "enum": [
            "apollo_persisted_query_manifest"
          ]
        },
        {
          "title": "json_key_value",
          "description": "A simple JSON map of key-value pairs.\nExample: `{\"key1\": \"query { __typename }\"}`",
          "type": "string",
          "enum": [
            "json_key_value"
          ]
        }
      ]
    },
    "PersistedOperationsProtocolConfig": {
      "oneOf": [
        {
          "title": "apollo_manifest_extensions",
          "description": "This protocol is based on [Apollo's Persisted Query Extensions](https://www.apollographql.com/docs/kotlin/advanced/persisted-queries/#2-publish-operation-manifest). The GraphQL operation key is sent over `POST` and contains `extensions` field with the GraphQL document hash.\nExample: `POST /graphql {\"extensions\": {\"persistedQuery\": {\"version\": 1, \"sha256Hash\": \"123\"}}`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "apollo_manifest_extensions"
              ]
            }
          }
        },
        {
          "title": "document_id",
          "description": "This protocol is based on a `POST` request with a JSON body containing a field with the document ID. By default, the field name is `documentId`.\nExample: `POST /graphql {\"documentId\": \"123\", \"variables\": {\"code\": \"AF\"}, \"operationName\": \"test\"}`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "document_id"
              ]
            },
            "field_name": {
              "description": "The name of the JSON field containing the document ID in the incoming request.",
              "default": "documentId",
              "type": "string"
            }
          }
        },
        {
          "title": "http_get",
          "description": "This protocol is based on a HTTP `GET` request. You can customize where to fetch each one of the parameters from. Each request parameter can be obtained from a different source: query, path, or header. By defualt, all parameters are obtained from the query string.\nUnlike other protocols, this protocol does not support sending GraphQL mutations.\nExample: `GET /graphql?documentId=123&variables=%7B%22code%22%3A%22AF%22%7D&operationName=test`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "http_get"
              ]
            },
            "document_id_from": {
              "description": "Instructions for fetching the document ID parameter from the incoming HTTP request.",
              "default": {
                "source": "search_query",
                "name": "documentId"
              },
              "$ref": "#/definitions/PersistedOperationHttpGetParameterLocation"
            },
            "variables_from": {
              "description": "Instructions for fetching the variables parameter from the incoming HTTP request. GraphQL variables must be passed as a JSON-encoded string.",
              "default": {
                "source": "search_query",
                "name": "variables"
              },
              "$ref": "#/definitions/PersistedOperationHttpGetParameterLocation"
            },
            "operation_name_from": {
              "description": "Instructions for fetching the operationName parameter from the incoming HTTP request.",
              "default": {
                "source": "search_query",
                "name": "operationName"
              },
              "$ref": "#/definitions/PersistedOperationHttpGetParameterLocation"
            }
          }
        }
      ]
    },
    "PersistedOperationHttpGetParameterLocation": {
      "oneOf": [
        {
          "title": "search_query",
          "description": "Instructs the plugin to extract this parameter from  the query string of the HTTP request.",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "search_query"
              ]
            },
            "name": {
              "description": "The name of the HTTP query parameter.",
              "type": "string"
            }
          }
        },
        {
          "title": "path",
          "description": "Instructs the plugin to extract this parameter from the path of the HTTP request.",
          "type": "object",
          "required": [
            "position",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "path"
              ]
            },
            "position": {
              "description": "The numeric value specific the location of the argument (starting from 0).",
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            }
          }
        },
        {
          "title": "header",
          "description": "Instructs the plugin to extract this parameter from a header in the HTTP request.",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "header"
              ]
            },
            "name": {
              "description": "The name of the HTTP header.",
              "type": "string"
            }
          }
        }
      ]
    }
  }
}