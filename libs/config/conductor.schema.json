{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "title": "ConductorConfig",
  "description": "This section describes the top-level configuration object for Conductor gateway.\n\nConductor supports both YAML and JSON format for the configuration file.\n\n## Loading the config file\n\nThe configuration is loaded when server starts, based on the runtime environment you are using:\n\n### Binary\n\nIf you are running the Conductor binary directly, you can specify the configuration file path using the first argument:\n\n```sh\n\nconductor my-config-file.json\n\n```\n\n> By default, Conductor will look for a file named `config.json` in the current directory.\n\n### Docker\n\nIf you are using Docker environment, you can mount the configuration file into the container, and then point the Conductor binary to it:\n\n```sh\n\ndocker run -v my-config-file.json:/app/config.json the-guild-org/conductor:latest /app/config.json\n\n```\n\n### CloudFlare Worker\n\nWASM runtime doesn't allow filesystem access, so you need to load the configuration file into an environment variable named `CONDUCTOR_CONFIG`.\n\n## Autocomplete/validation in VSCode\n\nFor JSON files, you can specify the `$schema` property to enable autocomplete and validation in VSCode:\n\n```json filename=\"config.json\"\n\n{ \"$schema\": \"https://raw.githubusercontent.com/the-guild-org/conductor/master/libs/config/conductor.schema.json\" }\n\n```\n\nFor YAML auto-complete and validation, you can install the [YAML Language Support](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml) extension and enable it by adding the following to your YAML file:\n\n```yaml filename=\"config.yaml\"\n\n$schema: \"https://raw.githubusercontent.com/the-guild-org/conductor/master/libs/config/conductor.schema.json\"\n\n```\n\n### JSONSchema\n\nAs part of the release flow of Conductor, we are publishing the configuration schema as a JSONSchema file.\n\nYou can find [here the latest version of the schema](https://github.com/the-guild-org/conductor/releases).\n\n### Configuration Interpolation with Environment Variables\n\nThis feature allows the dynamic insertion of environment variables into the config file for Conductor. It enhances flexibility by adapting the configuration based on the runtime environment.\n\nSyntax for Environment Variable Interpolation: - Use `${VAR_NAME}` to insert the value of an environment variable. If `VAR_NAME` is not set, an error will pop up. - Specify a default value with `${VAR_NAME:default_value}` which is used when `VAR_NAME` is not set. - Escape a dollar sign by preceding it with a backslash (e.g., `\\$`) to use it as a literal character instead of triggering interpolation.\n\nExamples: - `endpoint: ${API_ENDPOINT:https://api.example.com/}` - Uses the `API_ENDPOINT` variable or defaults to the provided URL. - `name: \\$super` - Results in the literal string `name: \\$super` in the configuration.",
  "type": "object",
  "required": [
    "endpoints",
    "sources"
  ],
  "properties": {
    "endpoints": {
      "description": "List of GraphQL endpoints to be exposed by the gateway. Each endpoint is a GraphQL schema that is backed by one or more sources and can have a unique set of plugins applied to.\n\nFor additional information, please refer to the [Endpoints section](./endpoints).",
      "type": "array",
      "items": {
        "$ref": "#/definitions/EndpointDefinition"
      }
    },
    "logger": {
      "description": "Conductor logger configuration.",
      "anyOf": [
        {
          "$ref": "#/definitions/LoggerConfig"
        },
        {
          "type": "null"
        }
      ]
    },
    "plugins": {
      "description": "List of global plugins to be applied to all endpoints. Global plugins are applied before endpoint-specific plugins.",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/definitions/PluginDefinition"
      }
    },
    "server": {
      "description": "Configuration for the HTTP server.",
      "anyOf": [
        {
          "$ref": "#/definitions/ServerConfig"
        },
        {
          "type": "null"
        }
      ]
    },
    "sources": {
      "description": "List of sources to be used by the gateway. Each source is a GraphQL endpoint or multiple endpoints grouped using a federated implementation.\n\nFor additional information, please refer to the [Sources section](./sources/graphql).",
      "type": "array",
      "items": {
        "$ref": "#/definitions/SourceDefinition"
      }
    }
  },
  "definitions": {
    "CorsPluginConfig": {
      "description": "The `cors` plugin enables [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) configuration for your GraphQL API.\n\nBy using this plugin, you can define rules for allowing cross-origin requests to your GraphQL server. This is essential for web applications that need to interact with your API from different domains.",
      "examples": [
        {
          "$metadata": {
            "title": "Strict CORS",
            "description": "This example demonstrates how to configure the CORS plugin with a strict list of methods, headers and origins."
          },
          "type": "cors",
          "enabled": true,
          "config": {
            "max_age": 3600,
            "allow_credentials": true,
            "allowed_methods": "GET, POST",
            "allowed_origin": "https://example.com",
            "allowed_headers": "Content-Type, Authorization",
            "allow_private_network": false
          }
        },
        {
          "$metadata": {
            "title": "Permissive CORS",
            "description": "This example demonstrates how to configure the CORS plugin with a permissive setup."
          },
          "type": "cors",
          "enabled": true,
          "config": {
            "max_age": 3600,
            "allow_credentials": true,
            "allowed_methods": "*",
            "allowed_origin": "*",
            "allowed_headers": "*",
            "exposed_headers": "*",
            "allow_private_network": true
          }
        },
        {
          "$metadata": {
            "title": "Reflect Origin",
            "description": "This example demonstrates how to configure the CORS plugin with a reflect Origin setup."
          },
          "type": "cors",
          "enabled": true,
          "config": {
            "max_age": 3600,
            "allow_credentials": true,
            "allowed_methods": "GET, POST",
            "allowed_origin": "reflect",
            "allowed_headers": "*",
            "exposed_headers": "*",
            "allow_private_network": false
          }
        }
      ],
      "type": "object",
      "properties": {
        "allow_credentials": {
          "description": "`Access-Control-Allow-Credentials`: Specifies whether to include credentials in the CORS headers. Credentials can include cookies, authorization headers, or TLS client certificates. Indicates whether the response to the request can be exposed when the credentials flag is true.",
          "default": false,
          "type": [
            "boolean",
            "null"
          ]
        },
        "allow_private_network": {
          "description": "`Access-Control-Allow-Private-Network`: Indicates whether requests from private networks are allowed when originating from public networks.",
          "default": false,
          "type": [
            "boolean",
            "null"
          ]
        },
        "allowed_headers": {
          "description": "`Access-Control-Allow-Headers`: Lists the headers allowed in actual requests. This helps in specifying which headers can be used when making the actual request. Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. You can also specify a special value \"*\" to allow any headers to be used when making the actual request, and the `Access-Control-Request-Headers` will be used from the incoming request.",
          "default": "*",
          "type": [
            "string",
            "null"
          ]
        },
        "allowed_methods": {
          "description": "`Access-Control-Allow-Methods`: Defines the HTTP methods allowed when accessing the resource. This is used in response to a CORS preflight request. Specifies the method or methods allowed when accessing the resource in response to a preflight request. You can also specify a special value \"*\" to allow any HTTP method to access the resource.",
          "default": "*",
          "type": [
            "string",
            "null"
          ]
        },
        "allowed_origin": {
          "description": "`Access-Control-Allow-Origin`: Determines which origins are allowed to access the resource. It can be a specific origin or a wildcard for allowing any origin. You can also specify a special value \"*\" to allow any origin to access the resource. You can also specify a special value \"reflect\" to allow the origin of the incoming request to access the resource.",
          "default": "*",
          "type": [
            "string",
            "null"
          ]
        },
        "exposed_headers": {
          "description": "`Access-Control-Expose-Headers`: The \"Access-Control-Expose-Headers\" response header allows a server to indicate which response headers should be made available to scripts running in the browser, in response to a cross-origin request. You can also specify a special value \"*\" to allow any headers to be exposed to scripts running in the browser.",
          "default": "*",
          "type": [
            "string",
            "null"
          ]
        },
        "max_age": {
          "description": "`Access-Control-Max-Age`: Indicates how long the results of a preflight request can be cached. This field represents the duration in seconds.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "DisableIntrospectionPluginConfig": {
      "description": "The `disable_introspection` plugin allows you to disable introspection for your GraphQL API.\n\nA [GraphQL introspection query](https://graphql.org/learn/introspection/) is a special GraphQL query that returns information about the GraphQL schema of your API.\n\nIt it [recommended to disable introspection for production environments](https://escape.tech/blog/should-i-disable-introspection-in-graphql/), unless you have a specific use-case for it.\n\nIt can either disable introspection for all requests, or only for requests that match a specific condition (using VRL scripting language).",
      "examples": [
        {
          "$metadata": {
            "title": "Disable Introspection",
            "description": "This example disables introspection for all requests for the configured Endpoint."
          },
          "type": "disable_introspection",
          "enabled": true,
          "config": {}
        },
        {
          "$metadata": {
            "title": "Conditional",
            "description": "This example disables introspection for all requests that doesn't have the \"bypass-introspection\" HTTP header."
          },
          "type": "disable_introspection",
          "enabled": true,
          "config": {
            "condition": {
              "from": "inline",
              "content": "%downstream_http_req.headers.\"bypass-introspection\" != \"1\""
            }
          }
        }
      ],
      "type": "object",
      "properties": {
        "condition": {
          "description": "A VRL condition that determines whether to disable introspection for the request. This condition is evaluated only if the incoming GraphQL request is detected as an introspection query.\n\nThe condition is evaluated in the context of the incoming request and have access to the metadata field `%downstream_http_req` (fields: `body`, `uri`, `query_string`, `method`, `headers`).\n\nThe condition must return a boolean value: return `true` to continue and disable the introspection, and `false` to allow the introspection to run.\n\nIn case of a runtime error, or an unexpected return value, the script will be ignored and introspection will be disabled for the incoming request.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "Duration": {
      "type": "object",
      "required": [
        "nanos",
        "secs"
      ],
      "properties": {
        "nanos": {
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "secs": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "EndpointDefinition": {
      "description": "The `Endpoint` object exposes a GraphQL source with set of plugins applied to it.\n\nEach Endpoint can have its own set of plugins, which are applied after the global plugins. Endpoints can expose the same source with different plugins applied to it, to create different sets of features for different clients or consumers.",
      "examples": [
        {
          "$metadata": {
            "title": "Basic Example",
            "description": "This example demonstrate how to declare a GraphQL source, and expose it as a GraphQL endpoint. The endpoint also exposes a GraphiQL interface."
          },
          "sources": [
            {
              "type": "graphql",
              "id": "my-source",
              "config": {
                "endpoint": "https://my-source.com/graphql"
              }
            }
          ],
          "endpoints": [
            {
              "path": "/graphql",
              "from": "my-source",
              "plugins": [
                {
                  "type": "graphiql"
                }
              ]
            }
          ]
        },
        {
          "$metadata": {
            "title": "Multiple Endpoints",
            "description": "This example shows how to expose a single GraphQL source with different plugins applied to it. In this example, we expose the same, one time with persised operations, and one time with HTTP GET for arbitrary queries."
          },
          "sources": [
            {
              "type": "graphql",
              "id": "my-source",
              "config": {
                "endpoint": "https://my-source.com/graphql"
              }
            }
          ],
          "endpoints": [
            {
              "path": "/trusted",
              "from": "my-source",
              "plugins": [
                {
                  "type": "trusted_documents",
                  "config": {
                    "store": {
                      "source": "file",
                      "path": "store.json",
                      "format": "json_key_value"
                    },
                    "protocols": [
                      {
                        "type": "document_id",
                        "field_name": ""
                      }
                    ],
                    "allow_untrusted": false
                  }
                }
              ]
            },
            {
              "path": "/data",
              "from": "my-source",
              "plugins": [
                {
                  "type": "http_get",
                  "config": {
                    "mutations": false
                  }
                }
              ]
            }
          ]
        }
      ],
      "type": "object",
      "required": [
        "from",
        "path"
      ],
      "properties": {
        "from": {
          "description": "The identifier of the `Source` to be used.\n\nThis must match the `id` field of a `Source` definition.",
          "type": "string"
        },
        "path": {
          "description": "A valid HTTP path to listen on for this endpoint. This will be used for the main GraphQL endpoint as well as for the GraphiQL endpoint. In addition, plugins that extends the HTTP layer will use this path as a base path.",
          "type": "string"
        },
        "plugins": {
          "description": "A list of unique plugins to be applied to this endpoint. These plugins will be applied after the global plugins.\n\nOrder of plugins is important: plugins are applied in the order they are defined.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/PluginDefinition"
          }
        }
      }
    },
    "FederationSourceConfig": {
      "type": "object",
      "required": [
        "supergraph"
      ],
      "properties": {
        "supergraph": {
          "description": "The endpoint URL for the GraphQL source.",
          "$ref": "#/definitions/SupergraphSourceConfig"
        }
      }
    },
    "GraphQLSourceConfig": {
      "description": "An upstream based on a simple, single GraphQL endpoint.\n\nBy using this source, you can easily wrap an existing GraphQL upstream server, and enrich it with features and plugins.",
      "examples": [
        {
          "$metadata": {
            "title": "Simple",
            "description": null
          },
          "type": "graphql",
          "id": "my-source",
          "config": {
            "endpoint": "https://my-source.com/graphql"
          }
        }
      ],
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "endpoint": {
          "description": "The HTTP(S) endpoint URL for the GraphQL source.",
          "type": "string"
        }
      }
    },
    "GraphiQLPluginConfig": {
      "description": "This plugin adds a GraphiQL interface to your Endpoint.\n\nThis plugin is rendering the GraphiQL interface for HTTP `GET` requests, that are not intercepted by other plugins.",
      "examples": [
        {
          "$metadata": {
            "title": "Enable GraphiQL",
            "description": null
          },
          "type": "graphiql",
          "enabled": true,
          "config": {}
        }
      ],
      "type": "object",
      "properties": {
        "headers_editor_enabled": {
          "description": "Enable/disable the HTTP headers editor in the GraphiQL interface.",
          "default": true,
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "HttpGetPluginConfig": {
      "description": "The `http_get` plugin allows you to expose your GraphQL API over HTTP `GET` requests. This feature is fully compliant with the [GraphQL over HTTP specification](https://graphql.github.io/graphql-over-http/).\n\nBy enabling this plugin, you can execute GraphQL queries and mutations over HTTP `GET` requests, using HTTP query parameters, for example:\n\n`GET /graphql?query=query%20%7B%20__typename%20%7D`\n\n### Query Parameters\n\nFor complete documentation of the supported query parameters, see the [GraphQL over HTTP specification](https://graphql.github.io/graphql-over-http/draft/#sec-GET).\n\n- `query`: The GraphQL query to execute\n\n- `variables` (optional): A JSON-encoded string containing the GraphQL variables\n\n- `operationName` (optional): The name of the GraphQL operation to execute\n\n### Headers\n\nTo execute GraphQL queries over HTTP `GET` requests, you must set the `Content-Type` header to `application/json`, **or** the `Accept` header to `application/x-www-form-urlencoded` / `application/graphql-response+json`.",
      "examples": [
        {
          "$metadata": {
            "title": "Simple",
            "description": null
          },
          "type": "http_get",
          "enabled": true,
          "config": {}
        },
        {
          "$metadata": {
            "title": "Enable Mutations",
            "description": "This example enables mutations over HTTP GET requests."
          },
          "type": "http_get",
          "enabled": true,
          "config": {
            "mutations": true
          }
        }
      ],
      "type": "object",
      "properties": {
        "mutations": {
          "description": "Allow mutations over GET requests.\n\n**The option is disabled by default:** this restriction is necessary to conform with the long-established semantics of safe methods within HTTP.",
          "default": false,
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "JwksProviderSourceConfig": {
      "oneOf": [
        {
          "title": "local",
          "description": "A local file on the file-system. This file will be read once on startup and cached.",
          "type": "object",
          "required": [
            "path",
            "source"
          ],
          "properties": {
            "path": {
              "description": "A path to a local file on the file-system. Relative to the location of the root configuration file.",
              "$ref": "#/definitions/LocalFileReference"
            },
            "source": {
              "type": "string",
              "enum": [
                "local"
              ]
            }
          }
        },
        {
          "title": "remote",
          "description": "A remote JWKS provider. The JWKS will be fetched via HTTP/HTTPS and cached.",
          "type": "object",
          "required": [
            "source",
            "url"
          ],
          "properties": {
            "cache_duration": {
              "description": "Duration after which the cached JWKS should be expired. If not specified, the default value will be used.",
              "default": "10m",
              "anyOf": [
                {
                  "$ref": "#/definitions/Duration"
                },
                {
                  "type": "null"
                }
              ]
            },
            "prefetch": {
              "description": "If set to `true`, the JWKS will be fetched on startup and cached. In case of invalid JWKS, the error will be ignored and the plugin will try to fetch again when server receives the first request. If set to `false`, the JWKS will be fetched on-demand, when the first request comes in.",
              "type": [
                "boolean",
                "null"
              ]
            },
            "source": {
              "type": "string",
              "enum": [
                "remote"
              ]
            },
            "url": {
              "description": "The URL to fetch the JWKS key set from, via HTTP/HTTPS.",
              "type": "string"
            }
          }
        }
      ]
    },
    "JwtAuthPluginConfig": {
      "description": "The `jwt_auth` plugin implements the [JSON Web Tokens](https://jwt.io/introduction) specification.\n\nIt can be used to verify the JWT signature, and optionally validate the token issuer and audience. It can also forward the token and its claims to the upstream service.\n\nThe JWKS configuration can be either a local file on the file-system, or a remote JWKS provider.\n\nBy default, the plugin will look for the JWT token in the `Authorization` header, with the `Bearer` prefix.\n\nYou can also configure the plugin to reject requests that don't have a valid JWT token.",
      "examples": [
        {
          "$metadata": {
            "title": "Local JWKS",
            "description": "This example is loading a JWKS file from the local file-system. The token is looked up in the `Authorization` header."
          },
          "type": "jwt_auth",
          "enabled": true,
          "config": {
            "lookup_locations": [
              {
                "source": "header",
                "name": "Authorization",
                "prefix": "Bearer"
              }
            ],
            "jwks_providers": [
              {
                "source": "local",
                "path": "jwks.json"
              }
            ]
          }
        },
        {
          "$metadata": {
            "title": "Remote JWKS with prefetch",
            "description": "This example is loading a remote JWKS, when the server starts (prefetch). The token is looked up in the `Authorization` header."
          },
          "type": "jwt_auth",
          "enabled": true,
          "config": {
            "lookup_locations": [
              {
                "source": "header",
                "name": "Authorization",
                "prefix": "Bearer"
              }
            ],
            "jwks_providers": [
              {
                "source": "remote",
                "url": "https://example.com/jwks.json",
                "cache_duration": "10m",
                "prefetch": true
              }
            ]
          }
        },
        {
          "$metadata": {
            "title": "Reject Unauthenticated",
            "description": "This example is loading a remote JWKS, and looks for the token in the `auth` cookie. If the token is not present, the request will be rejected."
          },
          "type": "jwt_auth",
          "enabled": true,
          "config": {
            "reject_unauthenticated_requests": true,
            "jwks_providers": [
              {
                "source": "remote",
                "url": "https://example.com/jwks.json",
                "cache_duration": "10m",
                "prefetch": true
              }
            ],
            "lookup_locations": [
              {
                "source": "cookies",
                "name": "auth"
              }
            ]
          }
        },
        {
          "$metadata": {
            "title": "Claims Forwarding",
            "description": "This example is loading a remote JWKS, and looks for the token in the `jwt` cookie. If the token is not present, the request will be rejected. The token and its claims will be forwarded to the upstream service in the `X-Auth-Token` and `X-Auth-Claims` headers."
          },
          "type": "jwt_auth",
          "enabled": true,
          "config": {
            "forward_claims_to_upstream_header": "X-Auth-Claims",
            "jwks_providers": [
              {
                "source": "remote",
                "url": "https://example.com/jwks.json",
                "cache_duration": "10m",
                "prefetch": true
              }
            ],
            "lookup_locations": [
              {
                "source": "cookies",
                "name": "jwt"
              }
            ],
            "reject_unauthenticated_requests": true,
            "forward_token_to_upstream_header": "X-Auth-Token"
          }
        },
        {
          "$metadata": {
            "title": "Strict Validation",
            "description": "This example is using strict validation, where the token issuer and audience are checked."
          },
          "type": "jwt_auth",
          "enabled": true,
          "config": {
            "lookup_locations": [
              {
                "source": "cookies",
                "name": "jwt"
              }
            ],
            "jwks_providers": [
              {
                "source": "remote",
                "url": "https://example.com/jwks.json",
                "cache_duration": "10m",
                "prefetch": null
              }
            ],
            "issuers": [
              "https://example.com"
            ],
            "audiences": [
              "realm.myapp.com"
            ]
          }
        }
      ],
      "type": "object",
      "required": [
        "jwks_providers"
      ],
      "properties": {
        "allowed_algorithms": {
          "description": "List of allowed algorithms for verifying the JWT signature. If not specified, the default list of all supported algorithms in [`jsonwebtoken` crate](https://crates.io/crates/jsonwebtoken) are used.",
          "default": [
            "HS256",
            "HS384",
            "HS512",
            "RS256",
            "RS384",
            "RS512",
            "ES256",
            "ES384",
            "PS256",
            "PS384",
            "PS512",
            "EdDSA"
          ],
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "audiences": {
          "description": "The list of [JWT audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) are allowed to access. If this field is set, the token's `aud` field must be one of the values in this list, otherwise the token's `aud` field is not checked.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "forward_claims_to_upstream_header": {
          "description": "Forward the JWT claims to the upstream service in the specified header.",
          "type": [
            "string",
            "null"
          ]
        },
        "forward_token_to_upstream_header": {
          "description": "Forward the JWT token to the upstream service in the specified header.",
          "type": [
            "string",
            "null"
          ]
        },
        "issuers": {
          "description": "Specify the [principal](https://tools.ietf.org/html/rfc7519#section-4.1.1) that issued the JWT, usually a URL or an email address. If specified, it has to match the `iss` field in JWT, otherwise the token's `iss` field is not checked.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "jwks_providers": {
          "description": "A list of JWKS providers to use for verifying the JWT signature. Can be either a path to a local JSON of the file-system, or a URL to a remote JWKS provider.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/JwksProviderSourceConfig"
          }
        },
        "lookup_locations": {
          "description": "A list of locations to look up for the JWT token in the incoming HTTP request. The first one that is found will be used.",
          "default": [
            {
              "source": "header",
              "name": "Authorization",
              "prefix": "Bearer"
            }
          ],
          "type": "array",
          "items": {
            "$ref": "#/definitions/JwtAuthPluginLookupLocation"
          }
        },
        "reject_unauthenticated_requests": {
          "description": "If set to `true`, the entire request will be rejected if the JWT token is not present in the request.",
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "JwtAuthPluginLookupLocation": {
      "oneOf": [
        {
          "title": "header",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "name": {
              "type": "string"
            },
            "prefix": {
              "type": [
                "string",
                "null"
              ]
            },
            "source": {
              "type": "string",
              "enum": [
                "header"
              ]
            }
          }
        },
        {
          "title": "query_param",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "name": {
              "type": "string"
            },
            "source": {
              "type": "string",
              "enum": [
                "query_param"
              ]
            }
          }
        },
        {
          "title": "cookies",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "name": {
              "type": "string"
            },
            "source": {
              "type": "string",
              "enum": [
                "cookies"
              ]
            }
          }
        }
      ]
    },
    "LocalFileReference": {
      "type": "string",
      "format": "path"
    },
    "LoggerConfig": {
      "type": "object",
      "properties": {
        "filter": {
          "description": "Environment filter configuration as a string. This allows extremely powerful control over Conductor's logging.\n\nThe `filter` can specify various directives to filter logs based on module paths, span names, and specific fields. These directives can also be combined using commas as a separator.\n\n### Basic Usage: - `info` (logs all messages at info level and higher across all modules) - `error` (logs all messages at error level only, as it's the highest level of severity)\n\n### Module-Specific Logging: - `conductor::gateway=debug` (logs all debug messages for the 'conductor::gateway' module) - `conductor::engine::source=trace` (logs all trace messages for the 'conductor::engine::source' module)\n\n### Combining Directives: - `conductor::gateway=info,conductor::engine::source=trace` (sets info level for the gateway module and trace level for the engine's source module)\n\nThe syntax of directives is very flexible, allowing complex logging configurations.\n\nSee [tracing_subscriber::EnvFilter](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) for more information.",
          "default": "info",
          "type": "string"
        },
        "format": {
          "description": "Configured the logger format. See options below.\n\n- `pretty` format is human-readable, ideal for development and debugging. - `json` format is structured, suitable for production environments and log analysis tools. By default, `pretty` is used in TTY environments, and `json` is used in non-TTY environments.",
          "default": "pretty",
          "$ref": "#/definitions/LoggerConfigFormat"
        },
        "print_performance_info": {
          "description": "Emits performance information on in crucial areas of the gateway.",
          "default": false,
          "type": "boolean"
        }
      }
    },
    "LoggerConfigFormat": {
      "description": "A source definition for a GraphQL endpoint or a federated GraphQL implementation.",
      "oneOf": [
        {
          "description": "Compact Format (default): This logging format outputs minimal, compact logs. It focuses on the essential parts of the log message and its fields, making it suitable for production environments where performance and log size are crucial. Pros: - Efficient in terms of space and performance. - Easy to read for brief messages and simple logs. Cons: - May lack detailed context, making debugging a bit more challenging.",
          "type": "string",
          "enum": [
            "compact"
          ]
        },
        {
          "description": "Pretty Format: The pretty format is designed for enhanced readability, featuring more verbose output including well-formatted fields and context. Ideal for development and debugging purposes. Pros: - Highly readable and provides detailed context. - Easier to understand complex log messages. Cons: - More verbose, resulting in larger log sizes. - Potentially slower performance due to the additional formatting overhead.",
          "type": "string",
          "enum": [
            "pretty"
          ]
        },
        {
          "description": "JSON Format: This format outputs logs in JSON. It is particularly useful when integrating with tools that consume or process JSON logs, such as log aggregators and analysis systems. Pros: - Structured format makes it easy to parse and integrate with various tools. - Consistent and predictable output. Cons: - Can be verbose and harder to read directly by developers. - Slightly more overhead compared to simpler formats like compact.",
          "type": "string",
          "enum": [
            "json"
          ]
        }
      ]
    },
    "MockedSourceConfig": {
      "description": "A mocked upstream with a static response for all executed operations.",
      "type": "object",
      "required": [
        "response_data"
      ],
      "properties": {
        "response_data": {
          "$ref": "#/definitions/LocalFileReference"
        }
      }
    },
    "OpenTelemetryTarget": {
      "oneOf": [
        {
          "title": "stdout",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "stdout"
              ]
            }
          }
        },
        {
          "title": "Open Telemetry (OTLP)",
          "type": "object",
          "required": [
            "endpoint",
            "type"
          ],
          "properties": {
            "endpoint": {
              "type": "string"
            },
            "gzip_compression": {
              "default": false,
              "type": "boolean"
            },
            "protocol": {
              "default": "grpc",
              "$ref": "#/definitions/OtlpProtcol"
            },
            "timeout": {
              "default": "10s",
              "$ref": "#/definitions/Duration"
            },
            "type": {
              "type": "string",
              "enum": [
                "otlp"
              ]
            }
          }
        },
        {
          "title": "Datadog",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "agent_endpoint": {
              "default": "127.0.0.1:8126",
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "datadog"
              ]
            }
          }
        },
        {
          "title": "Jaeger",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "endpoint": {
              "default": "127.0.0.1:6831",
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "jaeger"
              ]
            }
          }
        }
      ]
    },
    "OtlpProtcol": {
      "type": "string",
      "enum": [
        "grpc",
        "http"
      ]
    },
    "PluginDefinition": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/GraphiQLPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "graphiql"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/CorsPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "cors"
              ]
            }
          }
        },
        {
          "description": "Configuration for the Disable Introspection plugin.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/DisableIntrospectionPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "disable_introspection"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/HttpGetPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "http_get"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "config": {
              "$ref": "#/definitions/VrlPluginConfig"
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "vrl"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "config": {
              "$ref": "#/definitions/TrustedDocumentsPluginConfig"
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "trusted_documents"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "config": {
              "$ref": "#/definitions/JwtAuthPluginConfig"
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "jwt_auth"
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "config": {
              "$ref": "#/definitions/TelemetryPluginConfig"
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "type": {
              "type": "string",
              "enum": [
                "opentelemetry"
              ]
            }
          }
        }
      ]
    },
    "ServerConfig": {
      "type": "object",
      "properties": {
        "host": {
          "description": "The host to listen on, default to 127.0.0.1",
          "default": "127.0.0.1",
          "type": "string"
        },
        "port": {
          "description": "The port to listen on, default to 9000",
          "default": 9000,
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        }
      }
    },
    "SourceDefinition": {
      "description": "A source definition for a GraphQL endpoint or a federated GraphQL implementation.",
      "oneOf": [
        {
          "description": "A simple, single GraphQL endpoint",
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "config": {
              "description": "The configuration for the GraphQL source.",
              "$ref": "#/definitions/GraphQLSourceConfig"
            },
            "id": {
              "description": "The identifier of the source. This is used to reference the source in the `from` field of an endpoint definition.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "graphql"
              ]
            }
          }
        },
        {
          "description": "A simple, single GraphQL endpoint",
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "config": {
              "description": "The configuration for the GraphQL source.",
              "$ref": "#/definitions/MockedSourceConfig"
            },
            "id": {
              "description": "The identifier of the source. This is used to reference the source in the `from` field of an endpoint definition.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "mocl"
              ]
            }
          }
        },
        {
          "description": "federation endpoint",
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "config": {
              "description": "The configuration for the GraphQL source.",
              "$ref": "#/definitions/FederationSourceConfig"
            },
            "id": {
              "description": "The identifier of the source. This is used to reference the source in the `from` field of an endpoint definition.",
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "federation"
              ]
            }
          }
        }
      ]
    },
    "SupergraphSourceConfig": {
      "oneOf": [
        {
          "description": "The file path for the Supergraph schema.",
          "type": "object",
          "required": [
            "file"
          ],
          "properties": {
            "file": {
              "$ref": "#/definitions/LocalFileReference"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "The environment variable that contains the Supergraph schema.",
          "type": "object",
          "required": [
            "env"
          ],
          "properties": {
            "env": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        {
          "description": "The remote endpoint where the Supergraph schema can be fetched.",
          "type": "object",
          "required": [
            "remote"
          ],
          "properties": {
            "remote": {
              "type": "object",
              "required": [
                "url"
              ],
              "properties": {
                "fetch_every": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "headers": {
                  "description": "Optional headers to include in the request (ex: for authentication)",
                  "type": [
                    "object",
                    "null"
                  ],
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "url": {
                  "description": "The URL endpoint from where to fetch the Supergraph schema.",
                  "type": "string"
                }
              }
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "TelemetryPluginConfig": {
      "type": "object",
      "required": [
        "targets"
      ],
      "properties": {
        "service_name": {
          "default": "conductor",
          "type": "string"
        },
        "targets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/OpenTelemetryTarget"
          }
        }
      }
    },
    "TrustedDocumentHttpGetParameterLocation": {
      "oneOf": [
        {
          "title": "search_query",
          "description": "Instructs the plugin to extract this parameter from  the query string of the HTTP request.",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "name": {
              "description": "The name of the HTTP query parameter.",
              "type": "string"
            },
            "source": {
              "type": "string",
              "enum": [
                "search_query"
              ]
            }
          }
        },
        {
          "title": "path",
          "description": "Instructs the plugin to extract this parameter from the path of the HTTP request.",
          "type": "object",
          "required": [
            "position",
            "source"
          ],
          "properties": {
            "position": {
              "description": "The numeric value specific the location of the argument (starting from 0).",
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            },
            "source": {
              "type": "string",
              "enum": [
                "path"
              ]
            }
          }
        },
        {
          "title": "header",
          "description": "Instructs the plugin to extract this parameter from a header in the HTTP request.",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "name": {
              "description": "The name of the HTTP header.",
              "type": "string"
            },
            "source": {
              "type": "string",
              "enum": [
                "header"
              ]
            }
          }
        }
      ]
    },
    "TrustedDocumentsFileFormat": {
      "oneOf": [
        {
          "title": "apollo_persisted_query_manifest",
          "description": "JSON file formated based on [Apollo Persisted Query Manifest](https://www.apollographql.com/docs/kotlin/advanced/persisted-queries/#1-generate-operation-manifest).",
          "type": "string",
          "enum": [
            "apollo_persisted_query_manifest"
          ]
        },
        {
          "title": "json_key_value",
          "description": "A simple JSON map of key-value pairs.\n\nExample: `{\"key1\": \"query { __typename }\"}`",
          "type": "string",
          "enum": [
            "json_key_value"
          ]
        }
      ]
    },
    "TrustedDocumentsPluginConfig": {
      "examples": [
        {
          "$metadata": {
            "title": "Local File Store",
            "description": "This example is using a local file called `trusted_documents.json` as a store, using the Key->Value map format. The protocol exposed is based on HTTP `POST`, using the `documentId` parameter from the request body."
          },
          "type": "trusted_documents",
          "enabled": true,
          "config": {
            "protocols": [
              {
                "type": "document_id",
                "field_name": "documentId"
              }
            ],
            "store": {
              "source": "file",
              "path": "trusted_documents.json",
              "format": "json_key_value"
            }
          }
        },
        {
          "$metadata": {
            "title": "HTTP GET",
            "description": "This example uses a local file store called `trusted_documents.json`, using the Key->Value map format. The protocol exposed is based on HTTP `GET`, and extracts all parameters from the query string."
          },
          "type": "trusted_documents",
          "enabled": true,
          "config": {
            "protocols": [
              {
                "type": "http_get",
                "document_id_from": {
                  "source": "search_query",
                  "name": "documentId"
                },
                "variables_from": {
                  "source": "search_query",
                  "name": "variables"
                },
                "operation_name_from": {
                  "source": "search_query",
                  "name": "operationName"
                }
              }
            ],
            "store": {
              "source": "file",
              "path": "trusted_documents.json",
              "format": "json_key_value"
            }
          }
        }
      ],
      "type": "object",
      "required": [
        "protocols",
        "store"
      ],
      "properties": {
        "allow_untrusted": {
          "description": "By default, this plugin does not allow untrusted operations to be executed. This is a security measure to prevent accidental exposure of operations that are not persisted.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "protocols": {
          "description": "A list of protocols to be exposed by this plugin. Each protocol defines how to obtain the document ID from the incoming request. You can specify multiple kinds of protocols, if needed.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/TrustedDocumentsProtocolConfig"
          }
        },
        "store": {
          "description": "The store defines the source of trusted documents. The store contents is a list of hashes and GraphQL documents that are allowed to be executed.",
          "$ref": "#/definitions/TrustedDocumentsPluginStoreConfig"
        }
      }
    },
    "TrustedDocumentsPluginStoreConfig": {
      "oneOf": [
        {
          "title": "file",
          "description": "File-based store configuration. The path specified is relative to the location of the root configuration file. The file contents are loaded into memory on startup. The file is not reloaded automatically. The file format is specified by the `format` field, based on the structure of your file.",
          "type": "object",
          "required": [
            "format",
            "path",
            "source"
          ],
          "properties": {
            "format": {
              "description": "The format and the expected structure of the loaded store file.",
              "$ref": "#/definitions/TrustedDocumentsFileFormat"
            },
            "path": {
              "description": "A path to a local file on the file-system. Relative to the location of the root configuration file.",
              "$ref": "#/definitions/LocalFileReference"
            },
            "source": {
              "type": "string",
              "enum": [
                "file"
              ]
            }
          }
        }
      ]
    },
    "TrustedDocumentsProtocolConfig": {
      "oneOf": [
        {
          "title": "apollo_manifest_extensions",
          "description": "This protocol is based on [Apollo's Persisted Query Extensions](https://www.apollographql.com/docs/kotlin/advanced/persisted-queries/#2-publish-operation-manifest). The GraphQL operation key is sent over `POST` and contains `extensions` field with the GraphQL document hash.\n\nExample: `POST /graphql {\"extensions\": {\"persistedQuery\": {\"version\": 1, \"sha256Hash\": \"123\"}}`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "apollo_manifest_extensions"
              ]
            }
          }
        },
        {
          "title": "document_id",
          "description": "This protocol is based on a `POST` request with a JSON body containing a field with the document ID. By default, the field name is `documentId`.\n\nExample: `POST /graphql {\"documentId\": \"123\", \"variables\": {\"code\": \"AF\"}, \"operationName\": \"test\"}`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "field_name": {
              "description": "The name of the JSON field containing the document ID in the incoming request.",
              "default": "documentId",
              "type": "string"
            },
            "type": {
              "type": "string",
              "enum": [
                "document_id"
              ]
            }
          }
        },
        {
          "title": "http_get",
          "description": "This protocol is based on a HTTP `GET` request. You can customize where to fetch each one of the parameters from. Each request parameter can be obtained from a different source: query, path, or header. By defualt, all parameters are obtained from the query string.\n\nUnlike other protocols, this protocol does not support sending GraphQL mutations.\n\nExample: `GET /graphql?documentId=123&variables=%7B%22code%22%3A%22AF%22%7D&operationName=test`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "document_id_from": {
              "description": "Instructions for fetching the document ID parameter from the incoming HTTP request.",
              "default": {
                "source": "search_query",
                "name": "documentId"
              },
              "$ref": "#/definitions/TrustedDocumentHttpGetParameterLocation"
            },
            "operation_name_from": {
              "description": "Instructions for fetching the operationName parameter from the incoming HTTP request.",
              "default": {
                "source": "search_query",
                "name": "operationName"
              },
              "$ref": "#/definitions/TrustedDocumentHttpGetParameterLocation"
            },
            "type": {
              "type": "string",
              "enum": [
                "http_get"
              ]
            },
            "variables_from": {
              "description": "Instructions for fetching the variables parameter from the incoming HTTP request. GraphQL variables must be passed as a JSON-encoded string.",
              "default": {
                "source": "search_query",
                "name": "variables"
              },
              "$ref": "#/definitions/TrustedDocumentHttpGetParameterLocation"
            }
          }
        }
      ]
    },
    "VrlConfigReference": {
      "oneOf": [
        {
          "title": "inline",
          "description": "Inline string for a VRL code snippet. The string is parsed and executed as a VRL plugin.",
          "type": "object",
          "required": [
            "content",
            "from"
          ],
          "properties": {
            "content": {
              "type": "string"
            },
            "from": {
              "type": "string",
              "enum": [
                "inline"
              ]
            }
          }
        },
        {
          "title": "file",
          "description": "File reference to a VRL file. The file is loaded and executed as a VRL plugin.",
          "type": "object",
          "required": [
            "from",
            "path"
          ],
          "properties": {
            "from": {
              "type": "string",
              "enum": [
                "file"
              ]
            },
            "path": {
              "$ref": "#/definitions/LocalFileReference"
            }
          }
        }
      ]
    },
    "VrlPluginConfig": {
      "description": "To simplify the process of extending the functionality of the GraphQL Gateway, we adopted a Rust-based script language called [VRL](https://vector.dev/docs/reference/vrl/).\n\nVRL language is intended for writing simple scripts that can be executed in the context of the GraphQL Gateway. VRL is focused around safety and performance: the script is compiled into Rust code when the server starts, and executed as a native Rust code ([you can find a comparison between VRL and other scripting languages here](https://github.com/YassinEldeeb/rust-embedded-langs-vs-native-benchmark)).\n\n> VRL was initially created to allow users to extend [Vector](https://vector.dev/), a high-performance observability data router, and adopted for Conductor to allow developers to extend the functionality of the GraphQL Gateway easily.\n\n### Writing VRL\n\nVRL is an expression-oriented language. A VRL program consists entirely of expressions, with every expression returning a value. You can define variables, call functions, and use operators to manipulate values.\n\n#### Variables and Functions\n\nThe following program defines a variable `myVar` with the value `\"myValue\"` and prints it to the console:\n\n```vrl\n\nmyVar = \"my value\"\n\nlog(myVar, level:\"info\")\n\n```\n\n#### Assignment\n\nThe `.` is used to set output values. In this example, we are setting the `x-authorization` header of the upstream HTTP request to `my-value`.\n\nHere's an example for a VRL program that extends Conductor's behavior by adding a custom HTTP header to all upstream HTTP requests:\n\n```vrl\n\n.upstream_http_req.headers.\"x-authorization\" = \"my-value\"\n\n```\n\n#### Metadata\n\nThe `%` is used to access metadata values. Note that metadata values are read only.\n\nThe following program is printing a metadata value to the console:\n\n```vrl\n\nlog(%downstream_http_req.headers.authorization, level:\"info\")\n\n```\n\n#### Further Reading\n\n- [VRL Playground](https://playground.vrl.dev/)\n\n- [VRL concepts documentation](https://vector.dev/docs/reference/vrl/#concepts)\n\n- [VRL syntax documentation](https://vector.dev/docs/reference/vrl/expressions/)\n\n- [Compiler errors documentation](https://vector.dev/docs/reference/vrl/errors/)\n\n- [VRL program examples](https://vector.dev/docs/reference/vrl/examples/)\n\n### Runtime Failure Handling\n\nSome VRL functions are fallible, meaning that they can error. Any potential errors thrown by fallible functions must be handled, a requirement enforced at compile time.\n\n```vrl\n\n# This function is fallible, and can create errors, so it must be handled.\n\nparsed, err = parse_json(\"invalid json\")\n\n```\n\nVRL function calls can be marked as infallible by adding a `!` suffix to the function call: (note that this might lead to runtime errors)\n\n```vrl\n\nparsed = parse_json!(\"invalid json\")\n\n```\n\n> In case of a runtime error of a fallible function call, an error will be returned to the end-user, and the gateway will not continue with the execution.\n\n### Input/Output\n\n#### `on_downstream_http_request`\n\nThe `on_downstream_http_request` hook is executed when a downstream HTTP request is received to the gateway from the end-user.\n\nThe following metadata inputs are available to the hook:\n\n- `%downstream_http_req.body` (type: `string`): The body string of the incoming HTTP request.\n\n- `%downstream_http_req.uri` (type: `string`): The URI of the incoming HTTP request.\n\n- `%downstream_http_req.query_string` (type: `string`): The query string of the incoming HTTP request.\n\n- `%downstream_http_req.method` (type: `string`): The HTTP method of the incoming HTTP request.\n\n- `%downstream_http_req.headers` (type: `object`): The HTTP headers of the incoming HTTP request.\n\nThe following output values are available to the hook:\n\n- `.graphql.operation` (type: `string`): The GraphQL operation string to be executed. If this value is set, the gateway will skip the lookup phase, and will use this GraphQL operation instead.\n\n- `.graphql.operation_name` (type: `string`): If multiple GraphQL operations are set in `.graphql.operation`, you can specify the executable operation by setting this value.\n\n- `.graphql.variables` (type: `object`): The GraphQL variables to be used when executing the GraphQL operation.\n\n- `.graphql.extensions` (type: `object`): The GraphQL extensions to be used when executing the GraphQL operation.\n\n#### `on_downstream_graphql_request`\n\nThe `on_downstream_graphql_request` hook is executed when a GraphQL operation is extracted from a downstream HTTP request, and before the upstream GraphQL request is sent.\n\nThe following metadata inputs are available to the hook:\n\n- `%downstream_graphql_req.operation` (type: `string`): The GraphQL operation string, as extracted from the incoming HTTP request.\n\n- `%downstream_graphql_req.operation_name`(type: `string`) : If multiple GraphQL operations are set in `%downstream_graphql_req.operation`, you can specify the executable operation by setting this value.\n\n- `%downstream_graphql_req.variables` (type: `object`): The GraphQL variables, as extracted from the incoming HTTP request.\n\n- `%downstream_graphql_req.extensions` (type: `object`): The GraphQL extensions, as extracted from the incoming HTTP request.\n\nThe following output values are available to the hook:\n\n- `.graphql.operation` (type: `string`): The GraphQL operation string to be executed. If this value is set, it will override the existing operation.\n\n- `.graphql.operation_name` (type: `string`): If multiple GraphQL operations are set in `.graphql.operation`, you can override the extracted value by setting this field.\n\n- `%downstream_graphql_req.variables` (type: `object`): The GraphQL variables, as extracted from the incoming HTTP request. Setting this value will override the existing variables.\n\n- `%downstream_graphql_req.extensions` (type: `object`): The GraphQL extensions, as extracted from the incoming HTTP request. Setting this value will override the existing extensions.\n\n#### `on_upstream_http_request`\n\nThe `on_upstream_http_request` hook is executed when an HTTP request is about to be sent to the upstream GraphQL server.\n\nThe following metadata inputs are available to the hook:\n\n- `%upstream_http_req.body` (type: `string`): The body string of the planned HTTP request.\n\n- `%upstream_http_req.uri` (type: `string`): The URI of the planned HTTP request.\n\n- `%upstream_http_req.query_string` (type: `string`): The query string of the planned HTTP request.\n\n- `%upstream_http_req.method` (type: `string`): The HTTP method of the planned HTTP request.\n\n- `%upstream_http_req.headers` (type: `object`): The HTTP headers of the planned HTTP request.\n\nThe following output values are available to the hook:\n\n- `.upstream_http_req.body` (type: `string`): The body string of the planned HTTP request. Setting this value will override the existing body.\n\n- `.upstream_http_req.uri` (type: `string`): The URI of the planned HTTP request. Setting this value will override the existing URI.\n\n- `.upstream_http_req.query_string` (type: `string`): The query string of the planned HTTP request. Setting this value will override the existing query string.\n\n- `.upstream_http_req.method` (type: `string`): The HTTP method of the planned HTTP request. Setting this value will override the existing HTTP method.\n\n- `.upstream_http_req.headers` (type: `object`): The HTTP headers of the planned HTTP request. Headers set here will only extend the existing headers. You can use `null` value if you wish to remove an existing header.\n\n#### `on_downstream_http_response`\n\nThe `on_downstream_http_response` hook is executed when a GraphQL response is received from the upstream GraphQL server, and before the response is sent to the end-user.\n\nThe following metadata inputs are available to the hook:\n\n- `%downstream_http_res.body` (type: `string`): The body string of the HTTP response.\n\n- `%downstream_http_res.status` (type: `number`): The status code of the HTTP response.\n\n- `%downstream_http_res.headers` (type: `object`): The HTTP headers of the HTTP response.\n\nThe following output values are available to the hook:\n\n- `.downstream_http_res.body` (type: `string`): The body string of the HTTP response. Setting this value will override the existing body.\n\n- `.downstream_http_res.status` (type: `number`): The status code of the HTTP response. Setting this value will override the existing status code.\n\n- `.downstream_http_res.headers` (type: `object`): The HTTP headers of the HTTP response. Headers set here will only extend the existing headers. You can use `null` value if you wish to remove an existing header.\n\n### Shared State\n\nDuring the execution of VRL programs, Conductor configures a shared state object for every incoming HTTP request.\n\nThis means that you can create type-safe shared state objects, and use them to share data between different VRL programs and hooks.\n\nYou can find an example for this in the **Examples** section below.\n\n### Available Functions",
      "examples": [
        {
          "$metadata": {
            "title": "Inline",
            "description": "Load and execute VRL plugins using inline configuration."
          },
          "type": "vrl",
          "enabled": true,
          "config": {
            "on_upstream_http_request": {
              "from": "inline",
              "content": ".upstream_http_req.headers.\"x-authorization\" = \"some-value\"\n                "
            }
          }
        },
        {
          "$metadata": {
            "title": "File",
            "description": "Load and execute VRL plugins using an external '.vrl' file."
          },
          "type": "vrl",
          "enabled": true,
          "config": {
            "on_upstream_http_request": {
              "from": "file",
              "path": "my_plugin.vrl"
            }
          }
        },
        {
          "$metadata": {
            "title": "Headers Passthrough",
            "description": "This example is using the shared-state feature to store the headers from the incoming HTTP request, and it pass it through to upstream calls."
          },
          "type": "vrl",
          "enabled": true,
          "config": {
            "on_upstream_http_request": {
              "from": "inline",
              "content": ".upstream_http_req.headers = incoming_headers\n                "
            },
            "on_downstream_http_request": {
              "from": "inline",
              "content": "incoming_headers = %downstream_http_req.headers\n                "
            }
          }
        },
        {
          "$metadata": {
            "title": "Shared State",
            "description": "The following example is configuring a variable, and use it later"
          },
          "type": "vrl",
          "enabled": true,
          "config": {
            "on_upstream_http_request": {
              "from": "inline",
              "content": ".upstream_http_req.headers.\"x-auth\" = authorization_header\n                "
            },
            "on_downstream_http_request": {
              "from": "inline",
              "content": "authorization_header = %downstream_http_req.headers.authorization\n                "
            }
          }
        },
        {
          "$metadata": {
            "title": "Short Circuit",
            "description": "The following example rejects all incoming requests that doesn't have the \"authorization\" header set."
          },
          "type": "vrl",
          "enabled": true,
          "config": {
            "on_downstream_http_request": {
              "from": "inline",
              "content": "if %downstream_http_req.headers.authorization == null {\nshort_circuit!(403, \"Missing authorization header\")\n}\n                "
            }
          }
        },
        {
          "$metadata": {
            "title": "Custom GraphQL Extraction",
            "description": "The following example is using a custom GraphQL extraction, overriding the default gateway behavior. In this example, we parse the incoming body as JSON and use the parsed value to find the GraphQL operation. Assuming the body structure is: `{ \"runThisQuery\": \"query { __typename }\", \"variables\": {  }`."
          },
          "type": "vrl",
          "enabled": true,
          "config": {
            "on_downstream_http_request": {
              "from": "inline",
              "content": "parsed_body = parse_json!(%downstream_http_req.body)\n.graphql.operation = parsed_body.runThisQuery\n.graphql.variables = parsed_body.variables\n                "
            }
          }
        }
      ],
      "type": "object",
      "properties": {
        "on_downstream_graphql_request": {
          "description": "A hook executed when a GraphQL query is extracted from a downstream HTTP request, and before the upstream GraphQL request is sent. This hooks allow you to easily manipulate the incoming GraphQL request.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_downstream_http_request": {
          "description": "A hook executed when a downstream HTTP request is received to the gateway from the end-user. This hook allow you to extract information from the request, for later use, or to reject a request quickly.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_downstream_http_response": {
          "description": "A hook executed when a GraphQL response is received from the upstream GraphQL server, and before the response is sent to the end-user. This hook allow you to manipulate the end-user response easily.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_upstream_http_request": {
          "description": "A hook executed when an HTTP request is about to be sent to the upstream GraphQL server. This hook allow you to manipulate upstream HTTP calls easily.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    }
  }
}