{
  "$schema": "https://json-schema.org/draft/2019-09/schema",
  "title": "ConductorConfig",
  "type": "object",
  "required": [
    "endpoints",
    "sources"
  ],
  "properties": {
    "server": {
      "description": "Configuration for the HTTP server.\n\nNote: for CloudFlare Worker runtime, this configuration is ignored.",
      "default": {
        "host": "127.0.0.1",
        "port": 9000
      },
      "anyOf": [
        {
          "$ref": "#/definitions/ServerConfig"
        },
        {
          "type": "null"
        }
      ]
    },
    "logger": {
      "description": "Conductor logger configuration.",
      "anyOf": [
        {
          "$ref": "#/definitions/LoggerConfig"
        },
        {
          "type": "null"
        }
      ]
    },
    "sources": {
      "description": "List of sources to be used by the gateway. Each source is a GraphQL endpoint or multiple endpoints grouped using a federated implementation.\n\nFor additional information, please refer to the [Sources section](./sources/graphql).",
      "type": "array",
      "items": {
        "$ref": "#/definitions/SourceDefinition"
      }
    },
    "endpoints": {
      "description": "List of GraphQL endpoints to be exposed by the gateway. Each endpoint is a GraphQL schema that is backed by one or more sources and can have a unique set of plugins applied to.\n\nFor additional information, please refer to the [Endpoints section](./endpoints).",
      "type": "array",
      "items": {
        "$ref": "#/definitions/EndpointDefinition"
      }
    },
    "plugins": {
      "description": "List of global plugins to be applied to all endpoints. Global plugins are applied before endpoint-specific plugins.",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/definitions/PluginDefinition"
      }
    },
    "cache_stores": {
      "description": "List of global cache stores to register that can be later attached to the caching plugin globally or under individual endpoints",
      "type": [
        "array",
        "null"
      ],
      "items": {
        "$ref": "#/definitions/CacheStoreConfig"
      }
    }
  },
  "definitions": {
    "ServerConfig": {
      "type": "object",
      "properties": {
        "port": {
          "description": "The port to listen on, default to 9000",
          "default": 9000,
          "type": "integer",
          "format": "uint16",
          "minimum": 0.0
        },
        "host": {
          "description": "The host to listen on, default to 127.0.0.1",
          "default": "127.0.0.1",
          "type": "string"
        }
      }
    },
    "LoggerConfig": {
      "type": "object",
      "properties": {
        "filter": {
          "description": "Environment filter configuration as a string. This allows extremely powerful control over Conductor's logging.\n\nThe `filter` can specify various directives to filter logs based on module paths, span names, and specific fields. These directives can also be combined using commas as a separator.\n\n**Basic Usage:**\n\n- `info` (logs all messages at info level and higher across all modules)\n\n- `error` (logs all messages at error level only, as it's the highest level of severity)\n\n**Module-Specific Logging:**\n\n- `conductor::gateway=debug` (logs all debug messages for the 'conductor::gateway' module)\n\n- `conductor::engine::source=trace` (logs all trace messages for the 'conductor::engine::source' module)\n\n**Combining Directives:**\n\n- `conductor::gateway=info,conductor::engine::source=trace` (sets info level for the gateway module and trace level for the engine's source module)\n\nThe syntax of directives is very flexible, allowing complex logging configurations.\n\nSee [tracing_subscriber::EnvFilter](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) for more information.",
          "default": "info",
          "type": "string"
        },
        "format": {
          "description": "Configured the logger format. See options below.\n\n- `pretty` format is human-readable, ideal for development and debugging.\n\n- `json` format is structured, suitable for production environments and log analysis tools.\n\nBy default, `pretty` is used in TTY environments, and `json` is used in non-TTY environments.",
          "default": "pretty",
          "$ref": "#/definitions/LoggerConfigFormat"
        },
        "print_performance_info": {
          "description": "Emits performance information on in crucial areas of the gateway.\n\nLook for `close` and `idle` spans printed in the logs.\n\nNote: this option is not enabled on WASM runtime, and will be ignored if specified.",
          "default": false,
          "type": "boolean"
        }
      }
    },
    "LoggerConfigFormat": {
      "description": "A source definition for a GraphQL endpoint or a federated GraphQL implementation.",
      "oneOf": [
        {
          "title": "compact",
          "description": "This logging format outputs minimal, compact logs. It focuses on the essential parts of the log message and its fields, making it suitable for production environments where performance and log size are crucial.\n\nPros:\n\n- Efficient in terms of space and performance.\n\n- Easy to read for brief messages and simple logs.\n\nCons:\n\n- May lack detailed context, making debugging a bit more challenging.",
          "type": "string",
          "enum": [
            "compact"
          ]
        },
        {
          "title": "pretty",
          "description": "The pretty format is designed for enhanced readability, featuring more verbose output including well-formatted fields and context. Ideal for development and debugging purposes.\n\nPros:\n\n- Highly readable and provides detailed context.\n\n- Easier to understand complex log messages.\n\nCons:\n\n- More verbose, resulting in larger log sizes.\n\n- Potentially slower performance due to the additional formatting overhead.",
          "type": "string",
          "enum": [
            "pretty"
          ]
        },
        {
          "title": "json",
          "description": "This format outputs logs in JSON. It is particularly useful when integrating with tools that consume or process JSON logs, such as log aggregators and analysis systems.\n\nPros:\n\n- Structured format makes it easy to parse and integrate with various tools.\n\n- Consistent and predictable output.\n\nCons:\n\n- Can be verbose and harder to read directly by developers.\n\n- Slightly more overhead compared to simpler formats like compact.",
          "type": "string",
          "enum": [
            "json"
          ]
        }
      ]
    },
    "SourceDefinition": {
      "description": "A source definition for a GraphQL endpoint or a federated GraphQL implementation.",
      "oneOf": [
        {
          "description": "A simple, single GraphQL endpoint",
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "graphql"
              ]
            },
            "id": {
              "description": "The identifier of the source. This is used to reference the source in the `from` field of an endpoint definition.",
              "type": "string"
            },
            "config": {
              "description": "The configuration for the GraphQL source.",
              "$ref": "#/definitions/GraphQLSourceConfig"
            }
          }
        },
        {
          "description": "A simple, single GraphQL endpoint",
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "mock"
              ]
            },
            "id": {
              "description": "The identifier of the source. This is used to reference the source in the `from` field of an endpoint definition.",
              "type": "string"
            },
            "config": {
              "description": "The configuration for the GraphQL source.",
              "$ref": "#/definitions/MockedSourceConfig"
            }
          }
        },
        {
          "description": "federation endpoint",
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "federation"
              ]
            },
            "id": {
              "description": "The identifier of the source. This is used to reference the source in the `from` field of an endpoint definition.",
              "type": "string"
            },
            "config": {
              "description": "The configuration for the GraphQL source.",
              "$ref": "#/definitions/FederationSourceConfig"
            }
          }
        }
      ]
    },
    "GraphQLSourceConfig": {
      "description": "An upstream based on a simple, single GraphQL endpoint.\n\nBy using this source, you can easily wrap an existing GraphQL upstream server, and enrich it with features and plugins.\n\n## Schema Awareness\n\nThis source supports `schema_awareness` configuration. With schema awareness, the gateway will load the upstream GraphQL schema and use that information during plugins execution.\n\nPlugins can access the schema and provide meaningful features, such as running GraphQL validation as part of the gateway.\n\n> Note: Schema Awareness is optional for the `graphql` source. When it's not specified, the gateway will act as a simple proxy, without any knowledge of the upstream schema. Plugins that rely on the schema will emit a warning and will be skipped.",
      "examples": [
        {
          "$metadata": {
            "description": null,
            "title": "Simple"
          },
          "config": {
            "endpoint": "https://my-source.com/graphql",
            "schema_awareness": null
          },
          "id": "my-source",
          "type": "graphql"
        },
        {
          "$metadata": {
            "description": "This example demonstrates how to enable schema awareness for a GraphQL source. The gateway will load the upstream schema and use that information in other plugins.",
            "title": "Schema Awareness (remote introspection)"
          },
          "config": {
            "endpoint": "https://my-source.com/graphql",
            "schema_awareness": {
              "format": "introspection",
              "on_error": "terminate",
              "polling_interval": "1m",
              "source": {
                "headers": {
                  "authorization": "Bearer TOKEN"
                },
                "method": "POST",
                "type": "remote",
                "url": "https://my-source.com/graphql"
              }
            }
          },
          "id": "my-source",
          "type": "graphql"
        },
        {
          "$metadata": {
            "description": "This example demonstrates how to enable schema awareness for a GraphQL source. The gateway will load the upstream schema and use that information in other plugins.",
            "title": "Schema Awareness (local sdl)"
          },
          "config": {
            "endpoint": "https://my-source.com/graphql",
            "schema_awareness": {
              "format": "sdl",
              "on_error": "terminate",
              "polling_interval": null,
              "source": {
                "path": "./introspection.json",
                "type": "file"
              }
            }
          },
          "id": "my-source",
          "type": "graphql"
        },
        {
          "$metadata": {
            "description": "This example demonstrates how to enable schema awareness for a GraphQL source. The gateway will load the upstream schema and use that information in other plugins.",
            "title": "Schema Awareness (inline)"
          },
          "config": {
            "endpoint": "https://my-source.com/graphql",
            "schema_awareness": {
              "format": "sdl",
              "on_error": "terminate",
              "polling_interval": null,
              "source": {
                "content": "type Query { noop: String }",
                "type": "inline"
              }
            }
          },
          "id": "my-source",
          "type": "graphql"
        }
      ],
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "endpoint": {
          "description": "The HTTP(S) endpoint URL for the GraphQL source.",
          "type": "string"
        },
        "schema_awareness": {
          "description": "Schema Awareness configuration for the source. Enabling this configuration will configure the gateway to load the upstream GraphQL schema and use that information in other plugins.\n\nWhen this configuration is not specified, Schema Awareness is disabled, and plugins will not have access to the upstream schema. In that case, the gateway will act as a simple proxy, without any knowledge of the upstream schema.",
          "anyOf": [
            {
              "$ref": "#/definitions/SchemaAwarenessConfig"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "SchemaAwarenessConfig": {
      "type": "object",
      "required": [
        "format",
        "source"
      ],
      "properties": {
        "format": {
          "description": "The expected format of the response/file.",
          "$ref": "#/definitions/SchemaAwarenessFormat"
        },
        "source": {
          "description": "The source of the schema awareness. Can be either a local file, an inline string (hardcoded or from environment variables), or a remote endpoint.",
          "$ref": "#/definitions/SchemaAwarenessSource"
        },
        "polling_interval": {
          "description": "Polling interval for reloading the schema awareness.\n\nThis field is ignored on WASM runtime.",
          "default": "1m",
          "type": [
            "string",
            "null"
          ]
        },
        "on_error": {
          "description": "What to do in case of a failure to load the schema awareness.",
          "default": "terminate",
          "$ref": "#/definitions/SchemaAwarenessConfigOnError"
        }
      }
    },
    "SchemaAwarenessFormat": {
      "oneOf": [
        {
          "title": "introspection",
          "description": "The schema awareness is provided as a GraphQL introspection response.\n\nPlease note that GraphQL introspection does not contain information about GraphQL directives usage, so it's not suitable for runtimes/plugins that rely on directives.",
          "type": "string",
          "enum": [
            "introspection"
          ]
        },
        {
          "title": "sdl",
          "description": "The schema awareness is provided as a GraphQL SDL schema.",
          "type": "string",
          "enum": [
            "sdl"
          ]
        }
      ]
    },
    "SchemaAwarenessSource": {
      "oneOf": [
        {
          "title": "file",
          "description": "Loads schema awareness from a local file.",
          "type": "object",
          "required": [
            "path",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "file"
              ]
            },
            "path": {
              "$ref": "#/definitions/LocalFileReference"
            }
          }
        },
        {
          "title": "inline",
          "description": "Loads schema awareness from an inline string. You can also use environment variable intropolation in this field.",
          "type": "object",
          "required": [
            "content",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "inline"
              ]
            },
            "content": {
              "type": "string"
            }
          }
        },
        {
          "title": "remote",
          "description": "Loads schema awareness from a remote endpoint.",
          "type": "object",
          "required": [
            "type",
            "url"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "remote"
              ]
            },
            "url": {
              "description": "Endpoint to load the schema awareness from.",
              "type": "string"
            },
            "headers": {
              "description": "Optional headers to include in the request (for example: authentication).\n\nBy default, when `format: introspection` is used, the gateway will add `Content-Type: application/json` and `Accept: application/json` to the request headers.",
              "default": {},
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "method": {
              "description": "HTTP method to use when fetching the schema awareness from the remote endpoint.\n\nBy default, this field is set to `GET`. If you are using `format: introspection`, you should change this property to be `POST`.",
              "default": "GET",
              "type": "string"
            }
          }
        }
      ]
    },
    "LocalFileReference": {
      "type": "string",
      "format": "path"
    },
    "SchemaAwarenessConfigOnError": {
      "oneOf": [
        {
          "title": "terminate",
          "description": "On binary runtime, this configuration will stop the gateway with an error.\n\nOn WASM runtime, this field will return 500 in case of a failure to load.",
          "type": "string",
          "enum": [
            "terminate"
          ]
        },
        {
          "title": "ignore",
          "description": "Ignores the failure and report it to the log, without stopping the gateway or interrupting the execution.",
          "type": "string",
          "enum": [
            "ignore"
          ]
        }
      ]
    },
    "MockedSourceConfig": {
      "description": "A mocked upstream with a static response for all executed operations.",
      "type": "object",
      "required": [
        "response_data"
      ],
      "properties": {
        "response_data": {
          "$ref": "#/definitions/LocalFileReference"
        }
      }
    },
    "FederationSourceConfig": {
      "description": "A source capable of loading a Supergraph schema based on the [Apollo Federation specification](https://www.apollographql.com/docs/federation/).\n\nThe loaded supergraph will be used to orchestrate the execution of the queries across the federated sources.\n\nThe input for this source can be a local file, an environment variable, or a remote endpoint.\n\nThe content of the Supergraph input needs to be a valid GraphQL SDL schema, with the Apollo Federation execution directives, usually produced by a schema registry.",
      "examples": [
        {
          "$metadata": {
            "description": "This example is loading a Supergraph schema from a remote endpoint, using the Hive CDN. ",
            "title": "Hive"
          },
          "config": {
            "expose_query_plan": false,
            "supergraph": {
              "polling_interval": "1m",
              "source": {
                "headers": {
                  "x-hive-cdn-key": "CDN_TOKEN"
                },
                "method": "GET",
                "type": "remote",
                "url": "https://cdn.graphql-hive.com/artifacts/v1/TARGET_ID/supergraph"
              }
            }
          },
          "id": "my-source",
          "type": "federation"
        },
        {
          "$metadata": {
            "description": null,
            "title": "From a file"
          },
          "config": {
            "expose_query_plan": false,
            "supergraph": {
              "polling_interval": null,
              "source": {
                "path": "./supergraph.graphql",
                "type": "file"
              }
            }
          },
          "id": "my-source",
          "type": "federation"
        }
      ],
      "type": "object",
      "required": [
        "supergraph"
      ],
      "properties": {
        "supergraph": {
          "description": "The endpoint URL for the GraphQL source.",
          "$ref": "#/definitions/SchemaAwarenessSupergraphConfig"
        },
        "expose_query_plan": {
          "description": "Exposes the query plan as JSON under \"extensions\"",
          "default": false,
          "type": "boolean"
        }
      }
    },
    "SchemaAwarenessSupergraphConfig": {
      "type": "object",
      "required": [
        "source"
      ],
      "properties": {
        "source": {
          "description": "The source of the schema awareness. Can be either a local file, an inline string (hardcoded or from environment variables), or a remote endpoint.",
          "$ref": "#/definitions/SchemaAwarenessSource"
        },
        "polling_interval": {
          "description": "Polling interval for reloading the schema awareness.\n\nThis field is ignored on WASM runtime.",
          "default": "1m",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "EndpointDefinition": {
      "description": "The `Endpoint` object exposes a GraphQL source with set of plugins applied to it.\n\nEach Endpoint can have its own set of plugins, which are applied after the global plugins. Endpoints can expose the same source with different plugins applied to it, to create different sets of features for different clients or consumers.",
      "examples": [
        {
          "$metadata": {
            "description": "This example demonstrate how to declare a GraphQL source, and expose it as a GraphQL endpoint. The endpoint also exposes a GraphiQL interface.",
            "title": "Basic Example"
          },
          "endpoints": [
            {
              "from": "my-source",
              "path": "/graphql",
              "plugins": [
                {
                  "type": "graphiql"
                }
              ]
            }
          ],
          "sources": [
            {
              "config": {
                "endpoint": "https://my-source.com/graphql",
                "schema_awareness": null
              },
              "id": "my-source",
              "type": "graphql"
            }
          ]
        },
        {
          "$metadata": {
            "description": "This example shows how to expose a single GraphQL source with different plugins applied to it. In this example, we expose the same, one time with persised operations, and one time with HTTP GET for arbitrary queries.",
            "title": "Multiple Endpoints"
          },
          "endpoints": [
            {
              "from": "my-source",
              "path": "/trusted",
              "plugins": [
                {
                  "config": {
                    "allow_untrusted": false,
                    "protocols": [
                      {
                        "field_name": "",
                        "type": "document_id"
                      }
                    ],
                    "store": {
                      "format": "json_key_value",
                      "path": "store.json",
                      "source": "file"
                    }
                  },
                  "type": "trusted_documents"
                }
              ]
            },
            {
              "from": "my-source",
              "path": "/data",
              "plugins": [
                {
                  "config": {
                    "mutations": false
                  },
                  "type": "http_get"
                }
              ]
            }
          ],
          "sources": [
            {
              "config": {
                "endpoint": "https://my-source.com/graphql",
                "schema_awareness": null
              },
              "id": "my-source",
              "type": "graphql"
            }
          ]
        }
      ],
      "type": "object",
      "required": [
        "from",
        "path"
      ],
      "properties": {
        "path": {
          "description": "A valid HTTP path to listen on for this endpoint. This will be used for the main GraphQL endpoint as well as for the GraphiQL endpoint. In addition, plugins that extends the HTTP layer will use this path as a base path.",
          "type": "string"
        },
        "from": {
          "description": "The identifier of the `Source` to be used.\n\nThis must match the `id` field of a `Source` definition.",
          "type": "string"
        },
        "plugins": {
          "description": "A list of unique plugins to be applied to this endpoint. These plugins will be applied after the global plugins.\n\nOrder of plugins is important: plugins are applied in the order they are defined.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "$ref": "#/definitions/PluginDefinition"
          }
        }
      }
    },
    "PluginDefinition": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "graphiql"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/GraphiQLPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "cors"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/CorsPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "description": "Configuration for the Disable Introspection plugin.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "disable_introspection"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/DisableIntrospectionPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "http_get"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/HttpGetPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "vrl"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "$ref": "#/definitions/VrlPluginConfig"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "trusted_documents"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "$ref": "#/definitions/TrustedDocumentsPluginConfig"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "jwt_auth"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "$ref": "#/definitions/JwtAuthPluginConfig"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "graphql_validation"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "anyOf": [
                {
                  "$ref": "#/definitions/GraphQLValidationPluginConfig"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "telemetry"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "$ref": "#/definitions/TelemetryPluginConfig"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "http_caching"
              ]
            },
            "enabled": {
              "default": true,
              "type": [
                "boolean",
                "null"
              ]
            },
            "config": {
              "$ref": "#/definitions/HttpCachePluginConfig"
            }
          }
        }
      ]
    },
    "GraphiQLPluginConfig": {
      "description": "This plugin adds a GraphiQL interface to your Endpoint.\n\nThis plugin is rendering the GraphiQL interface for HTTP `GET` requests, that are not intercepted by other plugins.",
      "examples": [
        {
          "$metadata": {
            "description": null,
            "title": "Enable GraphiQL"
          },
          "config": {},
          "enabled": true,
          "type": "graphiql"
        }
      ],
      "type": "object",
      "properties": {
        "headers_editor_enabled": {
          "description": "Enable/disable the HTTP headers editor in the GraphiQL interface.",
          "default": true,
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "CorsPluginConfig": {
      "description": "The `cors` plugin enables [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) configuration for your GraphQL API.\n\nBy using this plugin, you can define rules for allowing cross-origin requests to your GraphQL server. This is essential for web applications that need to interact with your API from different domains.",
      "examples": [
        {
          "$metadata": {
            "description": "This example demonstrates how to configure the CORS plugin with a strict list of methods, headers and origins.",
            "title": "Strict CORS"
          },
          "config": {
            "allow_credentials": true,
            "allow_private_network": false,
            "allowed_headers": "Content-Type, Authorization",
            "allowed_methods": "GET, POST",
            "allowed_origin": "https://example.com",
            "max_age": 3600
          },
          "enabled": true,
          "type": "cors"
        },
        {
          "$metadata": {
            "description": "This example demonstrates how to configure the CORS plugin with a permissive setup.",
            "title": "Permissive CORS"
          },
          "config": {
            "allow_credentials": true,
            "allow_private_network": true,
            "allowed_headers": "*",
            "allowed_methods": "*",
            "allowed_origin": "*",
            "exposed_headers": "*",
            "max_age": 3600
          },
          "enabled": true,
          "type": "cors"
        },
        {
          "$metadata": {
            "description": "This example demonstrates how to configure the CORS plugin with a reflect Origin setup.",
            "title": "Reflect Origin"
          },
          "config": {
            "allow_credentials": true,
            "allow_private_network": false,
            "allowed_headers": "*",
            "allowed_methods": "GET, POST",
            "allowed_origin": "reflect",
            "exposed_headers": "*",
            "max_age": 3600
          },
          "enabled": true,
          "type": "cors"
        }
      ],
      "type": "object",
      "properties": {
        "allow_credentials": {
          "description": "`Access-Control-Allow-Credentials`: Specifies whether to include credentials in the CORS headers. Credentials can include cookies, authorization headers, or TLS client certificates. Indicates whether the response to the request can be exposed when the credentials flag is true.",
          "default": false,
          "type": [
            "boolean",
            "null"
          ]
        },
        "allowed_methods": {
          "description": "`Access-Control-Allow-Methods`: Defines the HTTP methods allowed when accessing the resource. This is used in response to a CORS preflight request. Specifies the method or methods allowed when accessing the resource in response to a preflight request. You can also specify a special value \"*\" to allow any HTTP method to access the resource.",
          "default": "*",
          "type": [
            "string",
            "null"
          ]
        },
        "allowed_origin": {
          "description": "`Access-Control-Allow-Origin`: Determines which origins are allowed to access the resource. It can be a specific origin or a wildcard for allowing any origin. You can also specify a special value \"*\" to allow any origin to access the resource. You can also specify a special value \"reflect\" to allow the origin of the incoming request to access the resource.",
          "default": "*",
          "type": [
            "string",
            "null"
          ]
        },
        "allowed_headers": {
          "description": "`Access-Control-Allow-Headers`: Lists the headers allowed in actual requests. This helps in specifying which headers can be used when making the actual request. Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. You can also specify a special value \"*\" to allow any headers to be used when making the actual request, and the `Access-Control-Request-Headers` will be used from the incoming request.",
          "default": "*",
          "type": [
            "string",
            "null"
          ]
        },
        "exposed_headers": {
          "description": "`Access-Control-Expose-Headers`: The \"Access-Control-Expose-Headers\" response header allows a server to indicate which response headers should be made available to scripts running in the browser, in response to a cross-origin request. You can also specify a special value \"*\" to allow any headers to be exposed to scripts running in the browser.",
          "default": "*",
          "type": [
            "string",
            "null"
          ]
        },
        "allow_private_network": {
          "description": "`Access-Control-Allow-Private-Network`: Indicates whether requests from private networks are allowed when originating from public networks.",
          "default": false,
          "type": [
            "boolean",
            "null"
          ]
        },
        "max_age": {
          "description": "`Access-Control-Max-Age`: Indicates how long the results of a preflight request can be cached. This field represents the duration in seconds.",
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "DisableIntrospectionPluginConfig": {
      "description": "The `disable_introspection` plugin allows you to disable introspection for your GraphQL API.\n\nA [GraphQL introspection query](https://graphql.org/learn/introspection/) is a special GraphQL query that returns information about the GraphQL schema of your API.\n\nIt it [recommended to disable introspection for production environments](https://escape.tech/blog/should-i-disable-introspection-in-graphql/), unless you have a specific use-case for it.\n\nIt can either disable introspection for all requests, or only for requests that match a specific condition (using VRL scripting language).",
      "examples": [
        {
          "$metadata": {
            "description": "This example disables introspection for all requests for the configured Endpoint.",
            "title": "Disable Introspection"
          },
          "config": {},
          "enabled": true,
          "type": "disable_introspection"
        },
        {
          "$metadata": {
            "description": "This example disables introspection for all requests that doesn't have the \"bypass-introspection\" HTTP header.",
            "title": "Conditional"
          },
          "config": {
            "condition": {
              "content": "%downstream_http_req.headers.\"bypass-introspection\" != \"1\"",
              "from": "inline"
            }
          },
          "enabled": true,
          "type": "disable_introspection"
        }
      ],
      "type": "object",
      "properties": {
        "condition": {
          "description": "A VRL condition that determines whether to disable introspection for the request. This condition is evaluated only if the incoming GraphQL request is detected as an introspection query.\n\nThe condition is evaluated in the context of the incoming request and have access to the metadata field `%downstream_http_req` (fields: `body`, `uri`, `query_string`, `method`, `headers`).\n\nThe condition must return a boolean value: return `true` to continue and disable the introspection, and `false` to allow the introspection to run.\n\nIn case of a runtime error, or an unexpected return value, the script will be ignored and introspection will be disabled for the incoming request.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "VrlConfigReference": {
      "oneOf": [
        {
          "title": "inline",
          "description": "Inline string for a VRL code snippet. The string is parsed and executed as a VRL plugin.",
          "type": "object",
          "required": [
            "content",
            "from"
          ],
          "properties": {
            "from": {
              "type": "string",
              "enum": [
                "inline"
              ]
            },
            "content": {
              "type": "string"
            }
          }
        },
        {
          "title": "file",
          "description": "File reference to a VRL file. The file is loaded and executed as a VRL plugin.",
          "type": "object",
          "required": [
            "from",
            "path"
          ],
          "properties": {
            "from": {
              "type": "string",
              "enum": [
                "file"
              ]
            },
            "path": {
              "$ref": "#/definitions/LocalFileReference"
            }
          }
        }
      ]
    },
    "HttpGetPluginConfig": {
      "description": "The `http_get` plugin allows you to expose your GraphQL API over HTTP `GET` requests. This feature is fully compliant with the [GraphQL over HTTP specification](https://graphql.github.io/graphql-over-http/).\n\nBy enabling this plugin, you can execute GraphQL queries and mutations over HTTP `GET` requests, using HTTP query parameters, for example:\n\n`GET /graphql?query=query%20%7B%20__typename%20%7D`\n\n### Query Parameters\n\nFor complete documentation of the supported query parameters, see the [GraphQL over HTTP specification](https://graphql.github.io/graphql-over-http/draft/#sec-GET).\n\n- `query`: The GraphQL query to execute\n\n- `variables` (optional): A JSON-encoded string containing the GraphQL variables\n\n- `operationName` (optional): The name of the GraphQL operation to execute\n\n### Headers\n\nTo execute GraphQL queries over HTTP `GET` requests, you must set the `Content-Type` header to `application/json`, **or** the `Accept` header to `application/x-www-form-urlencoded` / `application/graphql-response+json`.",
      "examples": [
        {
          "$metadata": {
            "description": null,
            "title": "Simple"
          },
          "config": {},
          "enabled": true,
          "type": "http_get"
        },
        {
          "$metadata": {
            "description": "This example enables mutations over HTTP GET requests.",
            "title": "Enable Mutations"
          },
          "config": {
            "mutations": true
          },
          "enabled": true,
          "type": "http_get"
        }
      ],
      "type": "object",
      "properties": {
        "mutations": {
          "description": "Allow mutations over GET requests.\n\n**The option is disabled by default:** this restriction is necessary to conform with the long-established semantics of safe methods within HTTP.",
          "default": false,
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "VrlPluginConfig": {
      "description": "To simplify the process of extending the functionality of the GraphQL Gateway, we adopted a Rust-based script language called [VRL](https://vector.dev/docs/reference/vrl/).\n\nVRL language is intended for writing simple scripts that can be executed in the context of the GraphQL Gateway. VRL is focused around safety and performance: the script is compiled into Rust code when the server starts, and executed as a native Rust code ([you can find a comparison between VRL and other scripting languages here](https://github.com/YassinEldeeb/rust-embedded-langs-vs-native-benchmark)).\n\n> VRL was initially created to allow users to extend [Vector](https://vector.dev/), a high-performance observability data router, and adopted for Conductor to allow developers to extend the functionality of the GraphQL Gateway easily.\n\n### Writing VRL\n\nVRL is an expression-oriented language. A VRL program consists entirely of expressions, with every expression returning a value. You can define variables, call functions, and use operators to manipulate values.\n\n#### Variables and Functions\n\nThe following program defines a variable `myVar` with the value `\"myValue\"` and prints it to the console:\n\n```vrl\n\nmyVar = \"my value\"\n\nlog(myVar, level:\"info\")\n\n```\n\n#### Assignment\n\nThe `.` is used to set output values. In this example, we are setting the `x-authorization` header of the upstream HTTP request to `my-value`.\n\nHere's an example for a VRL program that extends Conductor's behavior by adding a custom HTTP header to all upstream HTTP requests:\n\n```vrl\n\n.upstream_http_req.headers.\"x-authorization\" = \"my-value\"\n\n```\n\n#### Metadata\n\nThe `%` is used to access metadata values. Note that metadata values are read only.\n\nThe following program is printing a metadata value to the console:\n\n```vrl\n\nlog(%downstream_http_req.headers.authorization, level:\"info\")\n\n```\n\n#### Further Reading\n\n- [VRL Playground](https://playground.vrl.dev/)\n\n- [VRL concepts documentation](https://vector.dev/docs/reference/vrl/#concepts)\n\n- [VRL syntax documentation](https://vector.dev/docs/reference/vrl/expressions/)\n\n- [Compiler errors documentation](https://vector.dev/docs/reference/vrl/errors/)\n\n- [VRL program examples](https://vector.dev/docs/reference/vrl/examples/)\n\n### Runtime Failure Handling\n\nSome VRL functions are fallible, meaning that they can error. Any potential errors thrown by fallible functions must be handled, a requirement enforced at compile time.\n\n```vrl\n\n# This function is fallible, and can create errors, so it must be handled.\n\nparsed, err = parse_json(\"invalid json\")\n\n```\n\nVRL function calls can be marked as infallible by adding a `!` suffix to the function call: (note that this might lead to runtime errors)\n\n```vrl\n\nparsed = parse_json!(\"invalid json\")\n\n```\n\n> In case of a runtime error of a fallible function call, an error will be returned to the end-user, and the gateway will not continue with the execution.\n\n### Input/Output\n\n#### `on_downstream_http_request`\n\nThe `on_downstream_http_request` hook is executed when a downstream HTTP request is received to the gateway from the end-user.\n\nThe following metadata inputs are available to the hook:\n\n- `%downstream_http_req.body` (type: `string`): The body string of the incoming HTTP request.\n\n- `%downstream_http_req.uri` (type: `string`): The URI of the incoming HTTP request.\n\n- `%downstream_http_req.query_string` (type: `string`): The query string of the incoming HTTP request.\n\n- `%downstream_http_req.method` (type: `string`): The HTTP method of the incoming HTTP request.\n\n- `%downstream_http_req.headers` (type: `object`): The HTTP headers of the incoming HTTP request.\n\nThe following output values are available to the hook:\n\n- `.graphql.operation` (type: `string`): The GraphQL operation string to be executed. If this value is set, the gateway will skip the lookup phase, and will use this GraphQL operation instead.\n\n- `.graphql.operation_name` (type: `string`): If multiple GraphQL operations are set in `.graphql.operation`, you can specify the executable operation by setting this value.\n\n- `.graphql.variables` (type: `object`): The GraphQL variables to be used when executing the GraphQL operation.\n\n- `.graphql.extensions` (type: `object`): The GraphQL extensions to be used when executing the GraphQL operation.\n\n#### `on_downstream_graphql_request`\n\nThe `on_downstream_graphql_request` hook is executed when a GraphQL operation is extracted from a downstream HTTP request, and before the upstream GraphQL request is sent.\n\nThe following metadata inputs are available to the hook:\n\n- `%downstream_graphql_req.operation` (type: `string`): The GraphQL operation string, as extracted from the incoming HTTP request.\n\n- `%downstream_graphql_req.operation_name`(type: `string`) : If multiple GraphQL operations are set in `%downstream_graphql_req.operation`, you can specify the executable operation by setting this value.\n\n- `%downstream_graphql_req.variables` (type: `object`): The GraphQL variables, as extracted from the incoming HTTP request.\n\n- `%downstream_graphql_req.extensions` (type: `object`): The GraphQL extensions, as extracted from the incoming HTTP request.\n\nThe following output values are available to the hook:\n\n- `.graphql.operation` (type: `string`): The GraphQL operation string to be executed. If this value is set, it will override the existing operation.\n\n- `.graphql.operation_name` (type: `string`): If multiple GraphQL operations are set in `.graphql.operation`, you can override the extracted value by setting this field.\n\n- `%downstream_graphql_req.variables` (type: `object`): The GraphQL variables, as extracted from the incoming HTTP request. Setting this value will override the existing variables.\n\n- `%downstream_graphql_req.extensions` (type: `object`): The GraphQL extensions, as extracted from the incoming HTTP request. Setting this value will override the existing extensions.\n\n#### `on_upstream_http_request`\n\nThe `on_upstream_http_request` hook is executed when an HTTP request is about to be sent to the upstream GraphQL server.\n\nThe following metadata inputs are available to the hook:\n\n- `%upstream_http_req.body` (type: `string`): The body string of the planned HTTP request.\n\n- `%upstream_http_req.uri` (type: `string`): The URI of the planned HTTP request.\n\n- `%upstream_http_req.query_string` (type: `string`): The query string of the planned HTTP request.\n\n- `%upstream_http_req.method` (type: `string`): The HTTP method of the planned HTTP request.\n\n- `%upstream_http_req.headers` (type: `object`): The HTTP headers of the planned HTTP request.\n\nThe following output values are available to the hook:\n\n- `.upstream_http_req.body` (type: `string`): The body string of the planned HTTP request. Setting this value will override the existing body.\n\n- `.upstream_http_req.uri` (type: `string`): The URI of the planned HTTP request. Setting this value will override the existing URI.\n\n- `.upstream_http_req.query_string` (type: `string`): The query string of the planned HTTP request. Setting this value will override the existing query string.\n\n- `.upstream_http_req.method` (type: `string`): The HTTP method of the planned HTTP request. Setting this value will override the existing HTTP method.\n\n- `.upstream_http_req.headers` (type: `object`): The HTTP headers of the planned HTTP request. Headers set here will only extend the existing headers. You can use `null` value if you wish to remove an existing header.\n\n#### `on_downstream_http_response`\n\nThe `on_downstream_http_response` hook is executed when a GraphQL response is received from the upstream GraphQL server, and before the response is sent to the end-user.\n\nThe following metadata inputs are available to the hook:\n\n- `%downstream_http_res.body` (type: `string`): The body string of the HTTP response.\n\n- `%downstream_http_res.status` (type: `number`): The status code of the HTTP response.\n\n- `%downstream_http_res.headers` (type: `object`): The HTTP headers of the HTTP response.\n\nThe following output values are available to the hook:\n\n- `.downstream_http_res.body` (type: `string`): The body string of the HTTP response. Setting this value will override the existing body.\n\n- `.downstream_http_res.status` (type: `number`): The status code of the HTTP response. Setting this value will override the existing status code.\n\n- `.downstream_http_res.headers` (type: `object`): The HTTP headers of the HTTP response. Headers set here will only extend the existing headers. You can use `null` value if you wish to remove an existing header.\n\n### Shared State\n\nDuring the execution of VRL programs, Conductor configures a shared state object for every incoming HTTP request.\n\nThis means that you can create type-safe shared state objects, and use them to share data between different VRL programs and hooks.\n\nYou can find an example for this in the **Examples** section below.\n\n### Available Functions",
      "examples": [
        {
          "$metadata": {
            "description": "Load and execute VRL plugins using inline configuration.",
            "title": "Inline"
          },
          "config": {
            "on_upstream_http_request": {
              "content": ".upstream_http_req.headers.\"x-authorization\" = \"some-value\"\n                ",
              "from": "inline"
            }
          },
          "enabled": true,
          "type": "vrl"
        },
        {
          "$metadata": {
            "description": "Load and execute VRL plugins using an external '.vrl' file.",
            "title": "File"
          },
          "config": {
            "on_upstream_http_request": {
              "from": "file",
              "path": "my_plugin.vrl"
            }
          },
          "enabled": true,
          "type": "vrl"
        },
        {
          "$metadata": {
            "description": "This example is using the shared-state feature to store the headers from the incoming HTTP request, and it pass it through to upstream calls.",
            "title": "Headers Passthrough"
          },
          "config": {
            "on_downstream_http_request": {
              "content": "incoming_headers = %downstream_http_req.headers\n                ",
              "from": "inline"
            },
            "on_upstream_http_request": {
              "content": ".upstream_http_req.headers = incoming_headers\n                ",
              "from": "inline"
            }
          },
          "enabled": true,
          "type": "vrl"
        },
        {
          "$metadata": {
            "description": "The following example is configuring a variable, and use it later",
            "title": "Shared State"
          },
          "config": {
            "on_downstream_http_request": {
              "content": "authorization_header = %downstream_http_req.headers.authorization\n                ",
              "from": "inline"
            },
            "on_upstream_http_request": {
              "content": ".upstream_http_req.headers.\"x-auth\" = authorization_header\n                ",
              "from": "inline"
            }
          },
          "enabled": true,
          "type": "vrl"
        },
        {
          "$metadata": {
            "description": "The following example rejects all incoming requests that doesn't have the \"authorization\" header set.",
            "title": "Short Circuit"
          },
          "config": {
            "on_downstream_http_request": {
              "content": "if %downstream_http_req.headers.authorization == null {\nshort_circuit!(403, \"Missing authorization header\")\n}\n                ",
              "from": "inline"
            }
          },
          "enabled": true,
          "type": "vrl"
        },
        {
          "$metadata": {
            "description": "The following example is using a custom GraphQL extraction, overriding the default gateway behavior. In this example, we parse the incoming body as JSON and use the parsed value to find the GraphQL operation. Assuming the body structure is: `{ \"runThisQuery\": \"query { __typename }\", \"variables\": {  }`.",
            "title": "Custom GraphQL Extraction"
          },
          "config": {
            "on_downstream_http_request": {
              "content": "parsed_body = parse_json!(%downstream_http_req.body)\n.graphql.operation = parsed_body.runThisQuery\n.graphql.variables = parsed_body.variables\n                ",
              "from": "inline"
            }
          },
          "enabled": true,
          "type": "vrl"
        }
      ],
      "type": "object",
      "properties": {
        "on_downstream_http_request": {
          "description": "A hook executed when a downstream HTTP request is received to the gateway from the end-user. This hook allow you to extract information from the request, for later use, or to reject a request quickly.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_downstream_graphql_request": {
          "description": "A hook executed when a GraphQL query is extracted from a downstream HTTP request, and before the upstream GraphQL request is sent. This hooks allow you to easily manipulate the incoming GraphQL request.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_upstream_http_request": {
          "description": "A hook executed when an HTTP request is about to be sent to the upstream GraphQL server. This hook allow you to manipulate upstream HTTP calls easily.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        },
        "on_downstream_http_response": {
          "description": "A hook executed when a GraphQL response is received from the upstream GraphQL server, and before the response is sent to the end-user. This hook allow you to manipulate the end-user response easily.",
          "anyOf": [
            {
              "$ref": "#/definitions/VrlConfigReference"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    "TrustedDocumentsPluginConfig": {
      "description": "This plugin allows you to define a list of trusted GraphQL documents that can be executed by the gateway (also called **Persisted Operations**).\n\nFor additional information, please refer to [Trusted Documents](https://benjie.dev/graphql/trusted-documents).",
      "examples": [
        {
          "$metadata": {
            "description": "This example is using a local file called `trusted_documents.json` as a store, using the Key->Value map format. The protocol exposed is based on HTTP `POST`, using the `documentId` parameter from the request body.",
            "title": "Local File Store"
          },
          "config": {
            "protocols": [
              {
                "field_name": "documentId",
                "type": "document_id"
              }
            ],
            "store": {
              "format": "json_key_value",
              "path": "trusted_documents.json",
              "source": "file"
            }
          },
          "enabled": true,
          "type": "trusted_documents"
        },
        {
          "$metadata": {
            "description": "This example uses a local file store called `trusted_documents.json`, using the Key->Value map format. The protocol exposed is based on HTTP `GET`, and extracts all parameters from the query string.",
            "title": "HTTP GET"
          },
          "config": {
            "protocols": [
              {
                "document_id_from": {
                  "name": "documentId",
                  "source": "search_query"
                },
                "operation_name_from": {
                  "name": "operationName",
                  "source": "search_query"
                },
                "type": "http_get",
                "variables_from": {
                  "name": "variables",
                  "source": "search_query"
                }
              }
            ],
            "store": {
              "format": "json_key_value",
              "path": "trusted_documents.json",
              "source": "file"
            }
          },
          "enabled": true,
          "type": "trusted_documents"
        }
      ],
      "type": "object",
      "required": [
        "protocols",
        "store"
      ],
      "properties": {
        "store": {
          "description": "The store defines the source of trusted documents. The store contents is a list of hashes and GraphQL documents that are allowed to be executed.",
          "$ref": "#/definitions/TrustedDocumentsPluginStoreConfig"
        },
        "protocols": {
          "description": "A list of protocols to be exposed by this plugin. Each protocol defines how to obtain the document ID from the incoming request. You can specify multiple kinds of protocols, if needed.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/TrustedDocumentsProtocolConfig"
          }
        },
        "allow_untrusted": {
          "description": "By default, this plugin does not allow untrusted operations to be executed. This is a security measure to prevent accidental exposure of operations that are not persisted.",
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "TrustedDocumentsPluginStoreConfig": {
      "oneOf": [
        {
          "title": "file",
          "description": "File-based store configuration. The path specified is relative to the location of the root configuration file. The file contents are loaded into memory on startup. The file is not reloaded automatically. The file format is specified by the `format` field, based on the structure of your file.",
          "type": "object",
          "required": [
            "format",
            "path",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "file"
              ]
            },
            "path": {
              "description": "A path to a local file on the file-system. Relative to the location of the root configuration file.",
              "$ref": "#/definitions/LocalFileReference"
            },
            "format": {
              "description": "The format and the expected structure of the loaded store file.",
              "$ref": "#/definitions/TrustedDocumentsFileFormat"
            }
          }
        }
      ]
    },
    "TrustedDocumentsFileFormat": {
      "oneOf": [
        {
          "title": "apollo_persisted_query_manifest",
          "description": "JSON file formated based on [Apollo Persisted Query Manifest](https://www.apollographql.com/docs/kotlin/advanced/persisted-queries/#1-generate-operation-manifest).",
          "type": "string",
          "enum": [
            "apollo_persisted_query_manifest"
          ]
        },
        {
          "title": "json_key_value",
          "description": "A simple JSON map of key-value pairs.\n\nExample: `{\"key1\": \"query { __typename }\"}`",
          "type": "string",
          "enum": [
            "json_key_value"
          ]
        }
      ]
    },
    "TrustedDocumentsProtocolConfig": {
      "oneOf": [
        {
          "title": "apollo_manifest_extensions",
          "description": "This protocol is based on [Apollo's Persisted Query Extensions](https://www.apollographql.com/docs/kotlin/advanced/persisted-queries/#2-publish-operation-manifest). The GraphQL operation key is sent over `POST` and contains `extensions` field with the GraphQL document hash.\n\nExample: `POST /graphql {\"extensions\": {\"persistedQuery\": {\"version\": 1, \"sha256Hash\": \"123\"}}`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "apollo_manifest_extensions"
              ]
            }
          }
        },
        {
          "title": "document_id",
          "description": "This protocol is based on a `POST` request with a JSON body containing a field with the document ID. By default, the field name is `documentId`.\n\nExample: `POST /graphql {\"documentId\": \"123\", \"variables\": {\"code\": \"AF\"}, \"operationName\": \"test\"}`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "document_id"
              ]
            },
            "field_name": {
              "description": "The name of the JSON field containing the document ID in the incoming request.",
              "default": "documentId",
              "type": "string"
            }
          }
        },
        {
          "title": "http_get",
          "description": "This protocol is based on a HTTP `GET` request. You can customize where to fetch each one of the parameters from. Each request parameter can be obtained from a different source: query, path, or header. By defualt, all parameters are obtained from the query string.\n\nUnlike other protocols, this protocol does not support sending GraphQL mutations.\n\nExample: `GET /graphql?documentId=123&variables=%7B%22code%22%3A%22AF%22%7D&operationName=test`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "http_get"
              ]
            },
            "document_id_from": {
              "description": "Instructions for fetching the document ID parameter from the incoming HTTP request.",
              "default": {
                "name": "documentId",
                "source": "search_query"
              },
              "$ref": "#/definitions/TrustedDocumentHttpGetParameterLocation"
            },
            "variables_from": {
              "description": "Instructions for fetching the variables parameter from the incoming HTTP request. GraphQL variables must be passed as a JSON-encoded string.",
              "default": {
                "name": "variables",
                "source": "search_query"
              },
              "$ref": "#/definitions/TrustedDocumentHttpGetParameterLocation"
            },
            "operation_name_from": {
              "description": "Instructions for fetching the operationName parameter from the incoming HTTP request.",
              "default": {
                "name": "operationName",
                "source": "search_query"
              },
              "$ref": "#/definitions/TrustedDocumentHttpGetParameterLocation"
            }
          }
        }
      ]
    },
    "TrustedDocumentHttpGetParameterLocation": {
      "oneOf": [
        {
          "title": "search_query",
          "description": "Instructs the plugin to extract this parameter from  the query string of the HTTP request.",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "search_query"
              ]
            },
            "name": {
              "description": "The name of the HTTP query parameter.",
              "type": "string"
            }
          }
        },
        {
          "title": "path",
          "description": "Instructs the plugin to extract this parameter from the path of the HTTP request.",
          "type": "object",
          "required": [
            "position",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "path"
              ]
            },
            "position": {
              "description": "The numeric value specific the location of the argument (starting from 0).",
              "type": "integer",
              "format": "uint",
              "minimum": 0.0
            }
          }
        },
        {
          "title": "header",
          "description": "Instructs the plugin to extract this parameter from a header in the HTTP request.",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "header"
              ]
            },
            "name": {
              "description": "The name of the HTTP header.",
              "type": "string"
            }
          }
        }
      ]
    },
    "JwtAuthPluginConfig": {
      "description": "The `jwt_auth` plugin implements the [JSON Web Tokens](https://jwt.io/introduction) specification.\n\nIt can be used to verify the JWT signature, and optionally validate the token issuer and audience. It can also forward the token and its claims to the upstream service.\n\nThe JWKS configuration can be either a local file on the file-system, or a remote JWKS provider.\n\nBy default, the plugin will look for the JWT token in the `Authorization` header, with the `Bearer` prefix.\n\nYou can also configure the plugin to reject requests that don't have a valid JWT token.",
      "examples": [
        {
          "$metadata": {
            "description": "This example is loading a JWKS file from the local file-system. The token is looked up in the `Authorization` header.",
            "title": "Local JWKS"
          },
          "config": {
            "jwks_providers": [
              {
                "path": "jwks.json",
                "source": "local"
              }
            ],
            "lookup_locations": [
              {
                "name": "Authorization",
                "prefix": "Bearer",
                "source": "header"
              }
            ]
          },
          "enabled": true,
          "type": "jwt_auth"
        },
        {
          "$metadata": {
            "description": "This example is loading a remote JWKS, when the server starts (prefetch). The token is looked up in the `Authorization` header.",
            "title": "Remote JWKS with prefetch"
          },
          "config": {
            "jwks_providers": [
              {
                "cache_duration": "10m",
                "prefetch": true,
                "source": "remote",
                "url": "https://example.com/jwks.json"
              }
            ],
            "lookup_locations": [
              {
                "name": "Authorization",
                "prefix": "Bearer",
                "source": "header"
              }
            ]
          },
          "enabled": true,
          "type": "jwt_auth"
        },
        {
          "$metadata": {
            "description": "This example is loading a remote JWKS, and looks for the token in the `auth` cookie. If the token is not present, the request will be rejected.",
            "title": "Reject Unauthenticated"
          },
          "config": {
            "jwks_providers": [
              {
                "cache_duration": "10m",
                "prefetch": true,
                "source": "remote",
                "url": "https://example.com/jwks.json"
              }
            ],
            "lookup_locations": [
              {
                "name": "auth",
                "source": "cookies"
              }
            ],
            "reject_unauthenticated_requests": true
          },
          "enabled": true,
          "type": "jwt_auth"
        },
        {
          "$metadata": {
            "description": "This example is loading a remote JWKS, and looks for the token in the `jwt` cookie. If the token is not present, the request will be rejected. The token and its claims will be forwarded to the upstream service in the `X-Auth-Token` and `X-Auth-Claims` headers.",
            "title": "Claims Forwarding"
          },
          "config": {
            "forward_claims_to_upstream_header": "X-Auth-Claims",
            "forward_token_to_upstream_header": "X-Auth-Token",
            "jwks_providers": [
              {
                "cache_duration": "10m",
                "prefetch": true,
                "source": "remote",
                "url": "https://example.com/jwks.json"
              }
            ],
            "lookup_locations": [
              {
                "name": "jwt",
                "source": "cookies"
              }
            ],
            "reject_unauthenticated_requests": true
          },
          "enabled": true,
          "type": "jwt_auth"
        },
        {
          "$metadata": {
            "description": "This example is using strict validation, where the token issuer and audience are checked.",
            "title": "Strict Validation"
          },
          "config": {
            "audiences": [
              "realm.myapp.com"
            ],
            "issuers": [
              "https://example.com"
            ],
            "jwks_providers": [
              {
                "cache_duration": "10m",
                "prefetch": null,
                "source": "remote",
                "url": "https://example.com/jwks.json"
              }
            ],
            "lookup_locations": [
              {
                "name": "jwt",
                "source": "cookies"
              }
            ]
          },
          "enabled": true,
          "type": "jwt_auth"
        }
      ],
      "type": "object",
      "required": [
        "jwks_providers"
      ],
      "properties": {
        "jwks_providers": {
          "description": "A list of JWKS providers to use for verifying the JWT signature. Can be either a path to a local JSON of the file-system, or a URL to a remote JWKS provider.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/JwksProviderSourceConfig"
          }
        },
        "issuers": {
          "description": "Specify the [principal](https://tools.ietf.org/html/rfc7519#section-4.1.1) that issued the JWT, usually a URL or an email address. If specified, it has to match the `iss` field in JWT, otherwise the token's `iss` field is not checked.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "audiences": {
          "description": "The list of [JWT audiences](https://tools.ietf.org/html/rfc7519#section-4.1.3) are allowed to access. If this field is set, the token's `aud` field must be one of the values in this list, otherwise the token's `aud` field is not checked.",
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "lookup_locations": {
          "description": "A list of locations to look up for the JWT token in the incoming HTTP request. The first one that is found will be used.",
          "default": [
            {
              "name": "Authorization",
              "prefix": "Bearer",
              "source": "header"
            }
          ],
          "type": "array",
          "items": {
            "$ref": "#/definitions/JwtAuthPluginLookupLocation"
          }
        },
        "reject_unauthenticated_requests": {
          "description": "If set to `true`, the entire request will be rejected if the JWT token is not present in the request.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "allowed_algorithms": {
          "description": "List of allowed algorithms for verifying the JWT signature. If not specified, the default list of all supported algorithms in [`jsonwebtoken` crate](https://crates.io/crates/jsonwebtoken) are used.",
          "default": [
            "HS256",
            "HS384",
            "HS512",
            "RS256",
            "RS384",
            "RS512",
            "ES256",
            "ES384",
            "PS256",
            "PS384",
            "PS512",
            "EdDSA"
          ],
          "type": [
            "array",
            "null"
          ],
          "items": {
            "type": "string"
          }
        },
        "forward_token_to_upstream_header": {
          "description": "Forward the JWT token to the upstream service in the specified header.",
          "type": [
            "string",
            "null"
          ]
        },
        "forward_claims_to_upstream_header": {
          "description": "Forward the JWT claims to the upstream service in the specified header.",
          "type": [
            "string",
            "null"
          ]
        }
      }
    },
    "JwksProviderSourceConfig": {
      "oneOf": [
        {
          "title": "local",
          "description": "A local file on the file-system. This file will be read once on startup and cached.",
          "type": "object",
          "required": [
            "path",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "local"
              ]
            },
            "path": {
              "description": "A path to a local file on the file-system. Relative to the location of the root configuration file.",
              "$ref": "#/definitions/LocalFileReference"
            }
          }
        },
        {
          "title": "remote",
          "description": "A remote JWKS provider. The JWKS will be fetched via HTTP/HTTPS and cached.",
          "type": "object",
          "required": [
            "source",
            "url"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "remote"
              ]
            },
            "url": {
              "description": "The URL to fetch the JWKS key set from, via HTTP/HTTPS.",
              "type": "string"
            },
            "cache_duration": {
              "description": "Duration after which the cached JWKS should be expired. If not specified, the default value will be used.",
              "default": "10m",
              "type": "string"
            },
            "prefetch": {
              "description": "If set to `true`, the JWKS will be fetched on startup and cached. In case of invalid JWKS, the error will be ignored and the plugin will try to fetch again when server receives the first request. If set to `false`, the JWKS will be fetched on-demand, when the first request comes in.",
              "type": [
                "boolean",
                "null"
              ]
            }
          }
        }
      ]
    },
    "JwtAuthPluginLookupLocation": {
      "oneOf": [
        {
          "title": "header",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "header"
              ]
            },
            "name": {
              "type": "string"
            },
            "prefix": {
              "type": [
                "string",
                "null"
              ]
            }
          }
        },
        {
          "title": "query_param",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "query_param"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        },
        {
          "title": "cookies",
          "type": "object",
          "required": [
            "name",
            "source"
          ],
          "properties": {
            "source": {
              "type": "string",
              "enum": [
                "cookies"
              ]
            },
            "name": {
              "type": "string"
            }
          }
        }
      ]
    },
    "GraphQLValidationPluginConfig": {
      "type": "object"
    },
    "TelemetryPluginConfig": {
      "description": "The `telemetry` plugin exports traces information about Conductor to a telemetry backend.\n\nThe telemetry plugin exports traces information about the following aspects of Conductor:\n\n- GraphQL parser (timing)\n\n- GraphQL execution (operation type, operation body, operation name, timing, errors)\n\n- Query planning (timing, operation body, operation name)\n\n- Incoming HTTP requests (attributes, timing, errors)\n\n- Outgoing HTTP requests (attributes, timing, errors)\n\nWhen used with a telemtry backend, you can expect to see the following information:\n\n![img](https://raw.githubusercontent.com/the-guild-org/conductor/master/website/public/assets/telemetry.png)",
      "type": "object",
      "required": [
        "targets"
      ],
      "properties": {
        "service_name": {
          "description": "Configures the service name that reports the telemetry data. This will appear in the telemetry data as the `service.name` attribute.",
          "default": "conductor",
          "type": "string"
        },
        "targets": {
          "description": "A list of telemetry targets to send telemetry data to.\n\nThe telemtry data is scoped per endpoint, and you can specify multiple targets if you need to export stats to multiple backends.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/TelemetryTarget"
          }
        }
      }
    },
    "TelemetryTarget": {
      "oneOf": [
        {
          "title": "stdout",
          "description": "Sends telemetry data to `stdout` in a human-readable format.\n\nUse this source for debugging purposes, or if you want to pipe the telemetry data to another process.",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "stdout"
              ]
            }
          }
        },
        {
          "title": "zipkin",
          "description": "Sends telemetry traces data to a [Zipkin](https://zipkin.io/) collector, using the HTTP protocol.\n\nTo get started with Zipkin, use the following command to start the Zipkin collector and UI in your local machine, using Docker:\n\n`docker run -d -p 9411:9411 openzipkin/zipkin`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "zipkin"
              ]
            },
            "collector_endpoint": {
              "description": "The Zipkin endpoint. Please use full URL endpoint format, e.g. `http://127.0.0.1:9411/api/v2/spans`.",
              "default": "http://127.0.0.1:9411/api/v2/spans",
              "type": "string"
            }
          }
        },
        {
          "title": "Open Telemetry (OTLP)",
          "description": "Sends telemetry traces data to an [OpenTelemetry](https://opentelemetry.io/) backend, using the [OTLP protocol](https://opentelemetry.io/docs/specs/otel/protocol/).\n\nYou can find [here a list backends that supports the OTLP format](https://github.com/magsther/awesome-opentelemetry#open-source).",
          "type": "object",
          "required": [
            "endpoint",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "otlp"
              ]
            },
            "endpoint": {
              "description": "The OTLP backend endpoint. The format is based on full URL, e.g. `http://localhost:7201`.",
              "type": "string"
            },
            "protocol": {
              "description": "The OTLP transport to use to export telemetry data.\n\n>  The gRPC transport is not supported on WASM runtime (CloudFlare Worker).",
              "default": "grpc",
              "$ref": "#/definitions/OtlpProtcol"
            },
            "timeout": {
              "description": "Export timeout. You can use the human-readable format in this field, e.g. `10s`.",
              "default": "10s",
              "type": "string"
            },
            "gzip_compression": {
              "description": "Whether to use gzip compression when sending telemetry data.\n\nPlease verify your backend supports and enables `gzip` compression before enabling this option.",
              "default": false,
              "type": "boolean"
            }
          }
        },
        {
          "title": "Datadog",
          "description": "Sends telemetry traces data to a [Datadog](https://www.datadoghq.com/) agent (local or remote).\n\nTo get started with Datadog, make sure you have a [Datadog agent running](https://docs.datadoghq.com/agent/?tab=source).",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "datadog"
              ]
            },
            "agent_endpoint": {
              "description": "The Datadog agent endpoint. The format is based on hostname and port only, e.g. `127.0.0.1:8126`.",
              "default": "127.0.0.1:8126",
              "type": "string"
            }
          }
        },
        {
          "title": "Jaeger",
          "description": "Sends telemetry traces data to a [Jaeger](https://www.jaegertracing.io/) backend, using the native protocol of [Jaeger (UDP) using `thrift`](https://www.jaegertracing.io/docs/next-release/getting-started/).\n\n> Note: Jaeger also [supports OTLP format](https://opentelemetry.io/blog/2022/jaeger-native-otlp/), so it's preferred to use the `otlp` target.\n\n>  This target is not available on WASM runtime (CloudFlare Worker).\n\nTo get started with Jaeger, use the following command to start the Jaeger backend and UI in your local machine, using Docker:\n\n`docker run -d -p6831:6831/udp -p6832:6832/udp -p16686:16686 jaegertracing/all-in-one:latest`",
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "jaeger"
              ]
            },
            "endpoint": {
              "description": "The UDP endpoint of the Jaeger backend. The format is based on hostname and port only, e.g. `127.0.0.1:6831`.",
              "default": "127.0.0.1:6831",
              "type": "string"
            }
          }
        }
      ]
    },
    "OtlpProtcol": {
      "oneOf": [
        {
          "title": "grpc",
          "description": "Uses GRPC with `tonic` to send telemetry data.",
          "type": "string",
          "enum": [
            "grpc"
          ]
        },
        {
          "title": "http",
          "description": "Uses HTTP with `http-proto` to send telemetry data.",
          "type": "string",
          "enum": [
            "http"
          ]
        }
      ]
    },
    "HttpCachePluginConfig": {
      "type": "object",
      "required": [
        "cache"
      ],
      "properties": {
        "cache": {
          "type": "string"
        },
        "max_age": {
          "default": 60,
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "CacheStoreConfig": {
      "oneOf": [
        {
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "redis"
              ]
            },
            "id": {
              "type": "string"
            },
            "config": {
              "$ref": "#/definitions/RedisConfig"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "in_memory"
              ]
            },
            "id": {
              "type": "string"
            },
            "config": {
              "$ref": "#/definitions/InMemoryConfig"
            }
          }
        },
        {
          "type": "object",
          "required": [
            "config",
            "id",
            "type"
          ],
          "properties": {
            "type": {
              "type": "string",
              "enum": [
                "cloudflare_kv"
              ]
            },
            "id": {
              "type": "string"
            },
            "config": {
              "$ref": "#/definitions/CloudflareKVConfig"
            }
          }
        }
      ]
    },
    "RedisConfig": {
      "description": "Configuration for Redis.",
      "type": "object",
      "required": [
        "connection_string"
      ],
      "properties": {
        "connection_string": {
          "description": "Connection string to the Redis server (e.g: \"redis://localhost:6379\").",
          "type": "string"
        },
        "database": {
          "description": "Redis database number. Default is 0.",
          "default": 0,
          "type": [
            "integer",
            "null"
          ],
          "format": "int64"
        },
        "cache_ttl_seconds": {
          "description": "Time-to-live for cache entries in seconds. Default is 600 seconds (10 minutes).",
          "default": 600,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        },
        "pool_size": {
          "description": "The maximum number of connections in the Redis connection pool. Default is 10.",
          "default": 10,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint32",
          "minimum": 0.0
        },
        "pool_timeout": {
          "description": "Timeout for acquiring a connection from the pool in seconds. Default is 5 seconds.",
          "default": 5,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "InMemoryConfig": {
      "description": "Configuration for In-Memory caching, it internally works using an LRU (Least Recently Used) eviction policy",
      "type": "object",
      "properties": {
        "max_size": {
          "description": "The maximum number of cache entries. Default is 1000 entries. When the cache reaches this size, it will start evicting entries based on the eviction policy.",
          "default": 1000,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint",
          "minimum": 0.0
        },
        "cache_ttl_seconds": {
          "description": "Time-to-live for cache entries in seconds. Default is 600 seconds (10 minutes). This is the duration after which a cache entry will be automatically removed.",
          "default": 600,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        }
      }
    },
    "CloudflareKVConfig": {
      "type": "object",
      "required": [
        "account_identifier",
        "api_token",
        "namespace_identifier"
      ],
      "properties": {
        "account_identifier": {
          "description": "The Cloudflare account identifier.",
          "type": "string"
        },
        "namespace_identifier": {
          "description": "The namespace identifier for the KV store.",
          "type": "string"
        },
        "api_token": {
          "description": "API token for authenticating with the Cloudflare API.",
          "type": "string"
        },
        "cache_ttl_seconds": {
          "description": "Optional: Override the default TTL (time-to-live) for cache entries. If not provided, Cloudflare's default TTL will be used.",
          "default": null,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        },
        "connection_timeout_seconds": {
          "description": "Optional: Specifies the connection timeout in seconds. Default: 30 seconds.",
          "default": 30,
          "type": [
            "integer",
            "null"
          ],
          "format": "uint64",
          "minimum": 0.0
        }
      }
    }
  }
}